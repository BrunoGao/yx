<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™ºèƒ½æ‰‹è¡¨è®¾å¤‡åˆ†æç³»ç»Ÿ</title>
    <script src="{{ url_for('static', filename='js/echarts.min.js') }}"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Microsoft YaHei', Arial, sans-serif; 
            background: transparent; 
            color: #fff; 
            padding: 20px;
        }
        
        .container { 
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 1400px; 
            margin: 0 auto; 
        }
        
        /* å¯æŠ˜å é¢æ¿æ ·å¼ */
        .collapsible-panel {
            background: rgba(1, 19, 38, 0.8);
            border-radius: 12px;
            border: 1px solid rgba(0, 228, 255, 0.2);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            backdrop-filter: blur(4px);
            margin-bottom: 20px;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .panel-header {
            padding: 20px;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 228, 255, 0.05);
            transition: background 0.3s ease;
        }

        .panel-header:hover {
            background: rgba(0, 228, 255, 0.1);
        }

        .panel-header h3 {
            color: #00e4ff;
            font-size: 20px;
            margin: 0;
            text-shadow: 0 0 10px rgba(0, 228, 255, 0.5);
        }

        .panel-toggle {
            color: #00e4ff;
            font-size: 18px;
            font-weight: bold;
            transition: transform 0.3s ease;
        }

        .panel-toggle.expanded {
            transform: rotate(180deg);
        }

        .panel-content {
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }

        .panel-content.expanded {
            max-height: 1000px;
            padding: 20px;
        }
        
        /* è¿‡æ»¤å™¨æ ·å¼ */
        .form-group {
            margin-bottom: 20px;
            flex: 1;
            min-width: 200px;
        }

        .form-group label {
            display: block;
            color: #00e4ff;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .filter-select {
            width: 100%;
            padding: 10px;
            background: rgba(1, 19, 38, 0.8);
            border: 1px solid rgba(0, 228, 255, 0.3);
            border-radius: 4px;
            color: #fff;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .filter-select:focus {
            outline: none;
            border-color: #00e4ff;
            box-shadow: 0 0 5px rgba(0, 228, 255, 0.5);
        }

        .filter-select option {
            background: rgba(1, 19, 38, 0.9);
            color: #fff;
            padding: 8px;
        }

        .send-btn {
            background: linear-gradient(45deg, #00e4ff, #00a8ff);
            color: #001529;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            width: 100%;
        }

        .send-btn:hover {
            background: linear-gradient(45deg, #00a8ff, #00e4ff);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 228, 255, 0.3);
        }

        /* è®¾å¤‡è¡¨æ ¼å®¹å™¨æ ·å¼ */
        .device-table-container {
            background: rgba(1, 19, 38, 0.8);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(0, 228, 255, 0.2);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            backdrop-filter: blur(4px);
            max-height: 500px;
            overflow: hidden;
            margin-bottom: 20px;
            position: relative;
        }

        /* è¡¨æ ¼å¤´éƒ¨æ ·å¼ */
        .table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(0, 228, 255, 0.1);
        }

        .table-title {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .table-title h2 {
            color: #00e4ff;
            font-size: 20px;
            margin: 0;
            font-weight: 600;
            text-shadow: 0 0 10px rgba(0, 228, 255, 0.5);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .device-count {
            background: linear-gradient(45deg, rgba(0, 228, 255, 0.2), rgba(0, 228, 255, 0.1));
            color: #00e4ff;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
            border: 1px solid rgba(0, 228, 255, 0.3);
            letter-spacing: 0.5px;
        }

        /* æ§åˆ¶é¢æ¿æ ·å¼ */
        .control-panel {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(0, 228, 255, 0.05);
            border-radius: 20px;
            border: 1px solid rgba(0, 228, 255, 0.2);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #52c41a;
            box-shadow: 0 0 6px rgba(82, 196, 26, 0.8);
            animation: pulse 2s infinite;
        }

        .status-dot.paused {
            background: #fa8c16;
            box-shadow: 0 0 6px rgba(250, 140, 22, 0.8);
            animation: none;
        }

        .status-text {
            color: #7ecfff;
            font-size: 12px;
            font-weight: 500;
            letter-spacing: 0.3px;
        }

        /* æŒ‰é’®ç»„æ ·å¼ */
        .button-group {
            display: flex;
            gap: 8px;
        }

        .control-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            letter-spacing: 0.3px;
            min-width: 90px;
            justify-content: center;
        }

        .control-btn.primary {
            background: linear-gradient(45deg, #00e4ff, #00a8ff);
            color: #001529;
        }

        .control-btn.primary:hover {
            background: linear-gradient(45deg, #00a8ff, #00e4ff);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 228, 255, 0.3);
        }

        .control-btn.secondary {
            background: linear-gradient(45deg, rgba(250, 140, 22, 0.8), rgba(255, 187, 0, 0.8));
            color: #fff;
        }

        .control-btn.secondary:hover {
            background: linear-gradient(45deg, rgba(255, 187, 0, 0.9), rgba(250, 140, 22, 0.9));
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(250, 140, 22, 0.3);
        }

        .control-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }

        .btn-icon {
            font-size: 14px;
        }

        #deviceTable {
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            border-radius: 8px;
        }

        /* è¡¨æ ¼åŸºç¡€æ ·å¼ */
        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            font-size: 14px;
            position: relative;
        }

        th {
            background: linear-gradient(180deg, rgba(0, 228, 255, 0.15) 0%, rgba(0, 228, 255, 0.05) 100%);
            color: #00e4ff;
            font-weight: 600;
            padding: 15px;
            text-align: left;
            border-bottom: 2px solid rgba(0, 228, 255, 0.2);
            text-shadow: 0 0 10px rgba(0, 228, 255, 0.3);
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(8px);
        }

        th:first-child { border-top-left-radius: 8px; }
        th:last-child { border-top-right-radius: 8px; }

        td {
            padding: 12px 15px;
            border-bottom: 1px solid rgba(0, 228, 255, 0.1);
            transition: all 0.3s ease;
            max-width: 200px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        tr:nth-child(even) {
            background: rgba(0, 228, 255, 0.03);
        }

        tr:hover td {
            background: rgba(0, 228, 255, 0.1);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 228, 255, 0.1);
        }

        /* çŠ¶æ€æ ‡ç­¾æ ·å¼ */
        .status-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            display: inline-block;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .status-badge:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .status-active {
            background: linear-gradient(45deg, rgba(82, 196, 26, 0.2) 0%, rgba(82, 196, 26, 0.4) 100%);
            color: #52c41a;
            border: 1px solid rgba(82, 196, 26, 0.3);
        }

        .status-inactive {
            background: linear-gradient(45deg, rgba(245, 34, 45, 0.2) 0%, rgba(245, 34, 45, 0.4) 100%);
            color: #f5222d;
            border: 1px solid rgba(245, 34, 45, 0.3);
        }

        .status-charging {
            background: linear-gradient(45deg, rgba(33, 150, 243, 0.2) 0%, rgba(33, 150, 243, 0.4) 100%);
            color: #2196f3;
            border: 1px solid rgba(33, 150, 243, 0.3);
            animation: pulse 1.5s infinite;
        }

        .status-not-charging {
            background: linear-gradient(45deg, rgba(250, 140, 22, 0.2) 0%, rgba(250, 140, 22, 0.4) 100%);
            color: #fa8c16;
            border: 1px solid rgba(250, 140, 22, 0.3);
        }

        .status-worn {
            background: linear-gradient(45deg, rgba(82, 196, 26, 0.2) 0%, rgba(82, 196, 26, 0.4) 100%);
            color: #52c41a;
            border: 1px solid rgba(82, 196, 26, 0.3);
        }

        .status-not-worn {
            background: linear-gradient(45deg, rgba(245, 34, 45, 0.2) 0%, rgba(245, 34, 45, 0.4) 100%);
            color: #f5222d;
            border: 1px solid rgba(245, 34, 45, 0.3);
        }

        /* ç”µæ± è¿›åº¦æ¡ */
        .battery-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .battery-visual {
            position: relative;
            width: 60px;
            height: 12px;
            border: 1px solid #666;
            border-radius: 4px;
            background-color: rgba(255, 255, 255, 0.1);
            overflow: hidden;
        }

        .battery-bar {
            height: 100%;
            transition: width 0.3s ease-in-out;
        }

        .battery-low .battery-bar { background: linear-gradient(90deg, #f5222d, #ff4d4f); }
        .battery-medium .battery-bar { background: linear-gradient(90deg, #fa8c16, #ffc53d); }
        .battery-high .battery-bar { background: linear-gradient(90deg, #52c41a, #73d13d); }

        .battery-text {
            font-size: 12px;
            font-weight: 600;
            min-width: 35px;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.4; }
            100% { opacity: 1; }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* å›¾è¡¨ç½‘æ ¼å®¹å™¨ */
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
        }

        .chart-container {
            background: rgba(1, 19, 38, 0.8);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(0, 228, 255, 0.2);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            backdrop-filter: blur(4px);
            height: 350px;
            transition: all 0.3s ease;
        }

        .chart-container:hover {
            border-color: rgba(0, 228, 255, 0.4);
            box-shadow: 0 12px 40px 0 rgba(31, 38, 135, 0.5);
        }

        /* ç”µæ± åˆ†æå›¾è¡¨è·¨ä¸¤åˆ— */
        .chart-container.full-width {
            grid-column: span 2;
            height: 400px;
        }

        /* æ»šåŠ¨æ¡ç¾åŒ– */
        #deviceTable::-webkit-scrollbar {
            width: 8px;
        }

        #deviceTable::-webkit-scrollbar-track {
            background: rgba(0, 228, 255, 0.1);
            border-radius: 4px;
        }

        #deviceTable::-webkit-scrollbar-thumb {
            background: rgba(0, 228, 255, 0.2);
            border-radius: 4px;
        }

        #deviceTable::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 228, 255, 0.3);
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .charts-grid {
                grid-template-columns: 1fr;
            }
            
            .chart-container.full-width {
                grid-column: span 1;
            }
            
            .form-group {
                min-width: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- è¿‡æ»¤å™¨é¢æ¿ -->
        <div class="collapsible-panel">
            <div class="panel-header" onclick="togglePanel('filterPanel')">
                <h3>ğŸ” è®¾å¤‡ç­›é€‰</h3>
                <span class="panel-toggle" id="filterPanelToggle">â–¼</span>
            </div>
            <div class="panel-content" id="filterPanelContent">
                <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                    <div class="form-group">
                        <label>è®¾å¤‡çŠ¶æ€ï¼š</label>
                        <select id="filterStatus" class="filter-select" onchange="updateDashboard()">
                            <option value="">å…¨éƒ¨çŠ¶æ€</option>
                            <option value="ACTIVE">åœ¨çº¿</option>
                            <option value="INACTIVE">ç¦»çº¿</option>
                </select>
            </div>
                    
                    <div class="form-group">
                        <label>å……ç”µçŠ¶æ€ï¼š</label>
                        <select id="filterCharging" class="filter-select" onchange="updateDashboard()">
                            <option value="">å…¨éƒ¨çŠ¶æ€</option>
                            <option value="CHARGING">å……ç”µä¸­</option>
                            <option value="NOT_CHARGING">æœªå……ç”µ</option>
                </select>
            </div>
                    
                    <div class="form-group">
                        <label>ä½©æˆ´çŠ¶æ€ï¼š</label>
                        <select id="filterWearable" class="filter-select" onchange="updateDashboard()">
                            <option value="">å…¨éƒ¨çŠ¶æ€</option>
                            <option value="WORN">å·²ä½©æˆ´</option>
                            <option value="NOT_WORN">æœªä½©æˆ´</option>
                        </select>
        </div>

                    <div class="form-group">
                        <label>ç”µæ± ç”µé‡ï¼š</label>
                        <select id="filterBattery" class="filter-select" onchange="updateDashboard()">
                            <option value="">å…¨éƒ¨èŒƒå›´</option>
                            <option value="low">ä½ç”µé‡ (0-20%)</option>
                            <option value="medium">ä¸­ç­‰ (21-70%)</option>
                            <option value="high">é«˜ç”µé‡ (71-100%)</option>
                        </select>
            </div>
                    
                    <div class="form-group" style="flex: 0; min-width: 120px; display: flex; align-items: end;">
                        <button id="resetFilter" class="send-btn" onclick="resetFilters()">é‡ç½®ç­›é€‰</button>
            </div>
            </div>
            </div>
        </div>

        <!-- è®¾å¤‡è¡¨æ ¼ -->
        <div class="device-table-container">
            <div class="table-header">
                <div class="table-title">
                    <h2>ğŸ“± æ™ºèƒ½è®¾å¤‡ç›‘æ§å°</h2>
                    <span id="deviceCount" class="device-count"></span>
                </div>
                <div class="control-panel">
                    <div class="status-indicator">
                        <span class="status-dot" id="statusDot"></span>
                        <span id="refreshStatus" class="status-text">å®æ—¶ç›‘æ§ä¸­</span>
                    </div>
                    <div class="button-group">
                        <button id="refreshBtn" class="control-btn primary" onclick="manualRefresh()">
                            <span class="btn-icon">ğŸ”„</span>
                            <span>æ‰‹åŠ¨åˆ·æ–°</span>
                        </button>
                        <button id="toggleAutoRefresh" class="control-btn secondary" onclick="toggleAutoRefresh()">
                            <span class="btn-icon" id="autoRefreshIcon">â¸ï¸</span>
                            <span id="autoRefreshText">æš‚åœè‡ªåŠ¨</span>
                        </button>
                    </div>
                </div>
            </div>
            <div id="deviceTable"></div>
        </div>

        <!-- ç»Ÿè®¡å›¾è¡¨ -->
        <div class="charts-grid">
            <!-- ç¬¬ä¸€è¡Œï¼šåŸºç¡€ç»Ÿè®¡ -->
            <div class="chart-container">
                <div id="departmentChart" style="width: 100%; height: 100%;"></div>
            </div>
            <div class="chart-container">
                <div id="statusChart" style="width: 100%; height: 100%;"></div>
            </div>
            
            <!-- ç¬¬äºŒè¡Œï¼šçŠ¶æ€åˆ†æ -->
            <div class="chart-container">
                <div id="chargingChart" style="width: 100%; height: 100%;"></div>
            </div>
            <div class="chart-container">
                <div id="wearableChart" style="width: 100%; height: 100%;"></div>
            </div>

            <!-- ç¬¬ä¸‰è¡Œï¼šç”µæ± å’Œç‰ˆæœ¬ -->
            <div class="chart-container">
                <div id="batteryChart" style="width: 100%; height: 100%;"></div>
            </div>
            <div class="chart-container">
                <div id="systemVersionChart" style="width: 100%; height: 100%;"></div>
            </div>

            <!-- ç¬¬å››è¡Œï¼šå†å²è¶‹åŠ¿åˆ†æï¼ˆè·¨è¶Šæ‰€æœ‰åˆ—ï¼‰ -->
            <div class="chart-container full-width">
                <div id="batteryTrendChart" style="width: 100%; height: 100%;"></div>
            </div>
            
            <!-- ç¬¬äº”è¡Œï¼šä½©æˆ´å’Œå……ç”µè¶‹åŠ¿ -->
            <div class="chart-container">
                <div id="wearTrendChart" style="width: 100%; height: 100%;"></div>
            </div>
            <div class="chart-container">
                <div id="chargingTrendChart" style="width: 100%; height: 100%;"></div>
            </div>
            
            <!-- ç¬¬å…­è¡Œï¼šè®¾å¤‡å¥åº·é›·è¾¾å›¾å’Œé¢„æµ‹åˆ†æ -->
            <div class="chart-container">
                <div id="deviceHealthRadar" style="width: 100%; height: 100%;"></div>
            </div>
            <div class="chart-container">
                <div id="batteryPredictionChart" style="width: 100%; height: 100%;"></div>
            </div>
            
            <!-- ç¬¬ä¸ƒè¡Œï¼šåœ¨çº¿ç‡è¶‹åŠ¿å’Œç‰ˆæœ¬åˆ†å¸ƒæ—¶é—´çº¿ï¼ˆè·¨è¶Šæ‰€æœ‰åˆ—ï¼‰ -->
            <div class="chart-container full-width">
                <div id="uptimeTrendChart" style="width: 100%; height: 100%;"></div>
            </div>
        </div>
    </div>

    <script>
        const chartInstances = new Map();
        let originalDeviceData = null;
        let currentFilteredData = null;
        
        // ç¼“å­˜ä¼ é€’è¿‡æ¥çš„è®¾å¤‡æ•°æ®
        let cachedDeviceInfo = null;
        
        // è‡ªåŠ¨åˆ·æ–°ç›¸å…³å˜é‡
        let autoRefreshTimer = null;
        let isAutoRefreshEnabled = true;
        const REFRESH_INTERVAL = 5000; // 5ç§’
        
        // ç›‘å¬æ¥è‡ªçˆ¶çª—å£çš„æ•°æ® - å¢å¼ºç‰ˆæœ¬
        window.addEventListener('message', function(event) {
            console.log('ğŸ“¨ device_viewæ”¶åˆ°messageäº‹ä»¶:', event);
            console.log('ğŸ“¨ äº‹ä»¶æ•°æ®:', event.data);
            console.log('ğŸ“¨ äº‹ä»¶æ¥æº:', event.origin);
            
            if (event.data && event.data.type === 'deviceInfo') {
                cachedDeviceInfo = event.data.data;
                console.log('âœ… æ¥æ”¶åˆ°ä¼ é€’çš„è®¾å¤‡æ•°æ®:', cachedDeviceInfo);
                
                // å‘é€ç¡®è®¤æ¶ˆæ¯ç»™çˆ¶çª—å£
                try {
                    event.source.postMessage({
                        type: 'dataReceived',
                        success: true,
                        timestamp: Date.now()
                    }, event.origin);
                    console.log('ğŸ“¤ å·²å‘é€æ•°æ®æ¥æ”¶ç¡®è®¤');
                } catch (e) {
                    console.error('âŒ å‘é€ç¡®è®¤æ¶ˆæ¯å¤±è´¥:', e);
                }
                
                // å¦‚æœå›¾è¡¨å·²åˆå§‹åŒ–ï¼Œç›´æ¥æ›´æ–°æ•°æ®
                if (chartInstances.size > 0) {
                    console.log('ğŸ“Š å›¾è¡¨å·²åˆå§‹åŒ–ï¼Œç«‹å³æ›´æ–°æ•°æ®');
                    updateDashboardWithCachedData();
                } else {
                    console.log('â³ å›¾è¡¨æœªåˆå§‹åŒ–ï¼Œç­‰å¾…initDashboardè°ƒç”¨');
                }
            } else {
                console.log('âš ï¸ æ”¶åˆ°çš„æ¶ˆæ¯ç±»å‹ä¸åŒ¹é…æˆ–æ•°æ®æ ¼å¼é”™è¯¯:', event.data);
            }
        });
        
        // ä½¿ç”¨ç¼“å­˜æ•°æ®æ›´æ–°ä»ªè¡¨æ¿
        function updateDashboardWithCachedData() {
            if (!cachedDeviceInfo) return;
            
            console.log('ğŸ“Š å¼€å§‹ä½¿ç”¨ç¼“å­˜æ•°æ®æ›´æ–°å›¾è¡¨:', cachedDeviceInfo);
            
            // å°†ç¼“å­˜çš„æ•°æ®è½¬æ¢ä¸ºè®¾å¤‡æ•°æ®æ ¼å¼
            const data = {
                success: true,
                data: {
                    devices: cachedDeviceInfo.devices || [],
                    deviceStatusCount: cachedDeviceInfo.deviceStatusCount || {},
                    deviceChargingCount: cachedDeviceInfo.deviceChargingCount || {},
                    deviceWearableCount: cachedDeviceInfo.deviceWearableCount || {},
                    deviceSystemVersionCount: cachedDeviceInfo.deviceSystemVersionCount || {},
                    departmentDeviceCount: cachedDeviceInfo.departmentDeviceCount || {},
                    batteryAnalysis: cachedDeviceInfo.batteryAnalysis || {}
                }
            };
            
            originalDeviceData = data;
            const devices = data.data.devices;
            const filtered = filterDevices(devices);
            currentFilteredData = filtered;
            
            console.log('ğŸ“‹ æ˜¾ç¤ºè®¾å¤‡è¡¨æ ¼ï¼Œè®¾å¤‡æ•°é‡:', filtered.length);
            displayDeviceTable(filtered);
            
            const aggregated = aggregateData(filtered);
            // ä¿®å¤ç”µæ± åˆ†å¸ƒæ•°æ®æ ¼å¼è½¬æ¢
            if (cachedDeviceInfo.chartData && cachedDeviceInfo.chartData.battery_distribution) {
                aggregated.batteryDistribution = {
                    low: cachedDeviceInfo.chartData.battery_distribution['0-20'] || 0,
                    medium: (cachedDeviceInfo.chartData.battery_distribution['21-50'] || 0) + (cachedDeviceInfo.chartData.battery_distribution['51-80'] || 0),
                    high: cachedDeviceInfo.chartData.battery_distribution['81-100'] || 0
                };
            }
            aggregated.batteryAnalysis = data.data.batteryAnalysis || {};
            
            console.log('ğŸ“ˆ æ›´æ–°å›¾è¡¨æ•°æ®:', aggregated);
            updateCharts(aggregated);
        }

        // é¢æ¿åˆ‡æ¢åŠŸèƒ½
        function togglePanel(panelId) {
            const content = document.getElementById(panelId + 'Content');
            const toggle = document.getElementById(panelId + 'Toggle');
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                toggle.classList.remove('expanded');
                toggle.textContent = 'â–¼';
            } else {
                content.classList.add('expanded');
                toggle.classList.add('expanded');
                toggle.textContent = 'â–²';
            }
        }

        // å…¨å±€æš´éœ²å‡½æ•°
        window.togglePanel = togglePanel;
        
        // æ‰‹åŠ¨åˆ·æ–°åŠŸèƒ½
        function manualRefresh() {
            const btn = document.getElementById('refreshBtn');
            const btnIcon = btn.querySelector('.btn-icon');
            const btnText = btn.querySelector('span:last-child');
            
            btnText.textContent = 'åˆ·æ–°ä¸­...';
            btnIcon.style.animation = 'spin 1s linear infinite';
            btn.disabled = true;
            
            console.log('ğŸ”„ æ‰‹åŠ¨åˆ·æ–°è®¾å¤‡æ•°æ®...');
            updateDashboard().then(() => {
                btnText.textContent = 'æ‰‹åŠ¨åˆ·æ–°';
                btnIcon.style.animation = '';
                btn.disabled = false;
                console.log('âœ… æ‰‹åŠ¨åˆ·æ–°å®Œæˆ');
            }).catch(error => {
                console.error('âŒ æ‰‹åŠ¨åˆ·æ–°å¤±è´¥:', error);
                btnText.textContent = 'åˆ·æ–°å¤±è´¥';
                btnIcon.textContent = 'âŒ';
                setTimeout(() => {
                    btnText.textContent = 'æ‰‹åŠ¨åˆ·æ–°';
                    btnIcon.textContent = 'ğŸ”„';
                    btnIcon.style.animation = '';
                    btn.disabled = false;
                }, 2000);
            });
        }
        
        // åˆ‡æ¢è‡ªåŠ¨åˆ·æ–°çŠ¶æ€
        function toggleAutoRefresh() {
            const btn = document.getElementById('toggleAutoRefresh');
            const status = document.getElementById('refreshStatus');
            const statusDot = document.getElementById('statusDot');
            const btnIcon = document.getElementById('autoRefreshIcon');
            const btnText = document.getElementById('autoRefreshText');
            
            if (isAutoRefreshEnabled) {
                // å…³é—­è‡ªåŠ¨åˆ·æ–°
                clearInterval(autoRefreshTimer);
                autoRefreshTimer = null;
                isAutoRefreshEnabled = false;
                btnIcon.textContent = 'â–¶ï¸';
                btnText.textContent = 'å¯åŠ¨ç›‘æ§';
                status.textContent = 'ç›‘æ§å·²æš‚åœ';
                statusDot.classList.add('paused');
                console.log('âŒ è‡ªåŠ¨åˆ·æ–°å·²å…³é—­');
            } else {
                // å¼€å¯è‡ªåŠ¨åˆ·æ–°
                startAutoRefresh();
                isAutoRefreshEnabled = true;
                btnIcon.textContent = 'â¸ï¸';
                btnText.textContent = 'æš‚åœè‡ªåŠ¨';
                status.textContent = 'å®æ—¶ç›‘æ§ä¸­';
                statusDot.classList.remove('paused');
                console.log('âœ… è‡ªåŠ¨åˆ·æ–°å·²å¼€å¯');
            }
        }
        
        // å¯åŠ¨è‡ªåŠ¨åˆ·æ–°
        function startAutoRefresh() {
            if (autoRefreshTimer) {
                clearInterval(autoRefreshTimer);
            }
            
            autoRefreshTimer = setInterval(() => {
                if (isAutoRefreshEnabled) {
                    console.log('ğŸ”„ è‡ªåŠ¨åˆ·æ–°è®¾å¤‡æ•°æ®...');
                    updateDashboard().catch(error => {
                        console.error('âŒ è‡ªåŠ¨åˆ·æ–°å¤±è´¥:', error);
                    });
                }
            }, REFRESH_INTERVAL);
        }
        
        // åœæ­¢è‡ªåŠ¨åˆ·æ–°
        function stopAutoRefresh() {
            if (autoRefreshTimer) {
                clearInterval(autoRefreshTimer);
                autoRefreshTimer = null;
            }
        }
        
        // å…¨å±€æš´éœ²åˆ·æ–°ç›¸å…³å‡½æ•°
        window.manualRefresh = manualRefresh;
        window.toggleAutoRefresh = toggleAutoRefresh;

        async function fetchDeviceInfo() {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const customerId = urlParams.get('customerId') || '1';
                const deptId = urlParams.get('deptId') || '';
                const userId = urlParams.get('userId') || '';

                const orgId = deptId || customerId;
                let url = `/get_devices_by_orgIdAndUserId?orgId=${orgId}`;
                if (userId && userId !== 'all') url += `&userId=${userId}`;
                
                console.log('ğŸ” è°ƒç”¨è®¾å¤‡API:', url);
                const response = await fetch(url);
                const result = await response.json();
                
                if (result.success) {
                    console.log('âœ… APIè¿”å›æˆåŠŸ:', result);
                    return result;
                }
                throw new Error('Failed to fetch device data');
            } catch (error) {
                console.error('âŒ Error fetching device data:', error);
                return null;
            }
        }

        function displayDeviceTable(devices) {
            const tableHtml = `
                <table>
                    <thead>
                        <tr>
                            <th>è®¾å¤‡ç¼–å·</th>
                            <th>æ‰€å±éƒ¨é—¨</th>
                            <th>ä½¿ç”¨äººå‘˜</th>
                            <th>è®¾å¤‡çŠ¶æ€</th>
                            <th>ç”µæ± ç”µé‡</th>
                            <th>å……ç”µçŠ¶æ€</th>
                            <th>ä½©æˆ´çŠ¶æ€</th>
                            <th>ç³»ç»Ÿç‰ˆæœ¬</th>
                            <th>æ›´æ–°æ—¶é—´</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${devices.map(device => {
                            const battery = parseInt(device.battery_level) || 0;
                            let batteryClass = 'battery-medium';
                            if (battery <= 20) batteryClass = 'battery-low';
                            else if (battery >= 71) batteryClass = 'battery-high';

                            return `
                                <tr>
                                    <td title="${device.serial_number}">${device.serial_number}</td>
                                    <td title="${device.department_name}">${device.department_name}</td>
                                    <td title="${device.user_name}">${device.user_name}</td>
                                    <td>
                                        <span class="status-badge ${device.status === 'ACTIVE' ? 'status-active' : 'status-inactive'}">
                                            ${device.status === 'ACTIVE' ? 'åœ¨çº¿' : 'ç¦»çº¿'}
                                        </span>
                                    </td>
                                    <td>
                                        <div class="battery-container">
                                            <div class="battery-visual ${batteryClass}">
                                                <div class="battery-bar" style="width: ${battery}%;"></div>
                                            </div>
                                            <span class="battery-text">${battery}%</span>
                                        </div>
                                    </td>
                                    <td>
                                        <span class="status-badge ${device.charging_status === 'CHARGING' ? 'status-charging' : 'status-not-charging'}">
                                            ${device.charging_status === 'CHARGING' ? 'å……ç”µä¸­' : 'æœªå……ç”µ'}
                                        </span>
                                    </td>
                                    <td>
                                        <span class="status-badge ${device.wearable_status === 'WORN' ? 'status-worn' : 'status-not-worn'}">
                                            ${device.wearable_status === 'WORN' ? 'å·²ä½©æˆ´' : 'æœªä½©æˆ´'}
                                        </span>
                                    </td>
                                    <td title="${device.system_software_version}">${device.system_software_version}</td>
                                    <td title="${device.update_time}">${device.update_time}</td>
                                </tr>
                            `;
                        }).join('')}
                    </tbody>
                </table>
            `;
            
            document.getElementById('deviceTable').innerHTML = tableHtml;
            document.getElementById('deviceCount').textContent = `å…± ${devices.length} å°è®¾å¤‡`;
        }

        function updateCharts(data) {
            // éƒ¨é—¨åˆ†å¸ƒé¥¼å›¾
            updateDepartmentChart(data.departmentDeviceCount);
            // è®¾å¤‡çŠ¶æ€æŸ±çŠ¶å›¾
            updateStatusChart(data.deviceStatusCount);
            // å……ç”µçŠ¶æ€é¥¼å›¾
            updateChargingChart(data.deviceChargingCount);
            // ä½©æˆ´çŠ¶æ€é¥¼å›¾
            updateWearableChart(data.deviceWearableCount);
            // ç”µæ± åˆ†å¸ƒæŸ±çŠ¶å›¾
            updateBatteryChart(data.batteryDistribution);
            // ç³»ç»Ÿç‰ˆæœ¬åˆ†å¸ƒ
            updateSystemVersionChart(data.deviceSystemVersionCount);
            // ç”µæ± è¶‹åŠ¿åˆ†æ
            updateBatteryTrendChart(data.batteryAnalysis);
        }

        function updateDepartmentChart(data) {
            const chart = chartInstances.get('departmentChart');
            if (!chart) {
                console.error('âŒ éƒ¨é—¨å›¾è¡¨æœªåˆå§‹åŒ–');
                return;
            }
            
            const chartData = Object.entries(data || {}).map(([name, value]) => ({ name, value }));
            console.log('ğŸ“Š éƒ¨é—¨åˆ†å¸ƒå›¾è¡¨æ•°æ®:', chartData);
            
            chart.setOption({
                title: { 
                    text: 'éƒ¨é—¨è®¾å¤‡åˆ†å¸ƒ', 
                    textStyle: { color: '#00e4ff', fontSize: 16 },
                    left: 'center'
                },
                tooltip: { 
                    trigger: 'item',
                    formatter: '{b}: {c}å° ({d}%)'
                },
                legend: {
                    orient: 'vertical',
                    left: 'left',
                    textStyle: { color: '#fff' }
                },
                series: [{
                    type: 'pie',
                    radius: ['40%', '70%'],
                    center: ['60%', '50%'],
                    data: chartData,
                    emphasis: {
                        itemStyle: {
                            shadowBlur: 10,
                            shadowOffsetX: 0,
                            shadowColor: 'rgba(0, 0, 0, 0.5)'
                        }
                    },
                    label: {
                        formatter: '{b}: {c}å°'
                    }
                }]
            });
        }

        function updateStatusChart(data) {
            const chart = chartInstances.get('statusChart');
            if (!chart) {
                console.error('âŒ çŠ¶æ€å›¾è¡¨æœªåˆå§‹åŒ–');
                return;
            }
            
            const activeCount = data.ACTIVE || 0;
            const inactiveCount = data.INACTIVE || 0;
            console.log('ğŸ“Š è®¾å¤‡çŠ¶æ€å›¾è¡¨æ•°æ®:', { active: activeCount, inactive: inactiveCount });
            
            chart.setOption({
                title: { 
                    text: 'è®¾å¤‡çŠ¶æ€åˆ†å¸ƒ', 
                    textStyle: { color: '#00e4ff', fontSize: 16 },
                    left: 'center'
                },
                tooltip: { 
                    trigger: 'axis',
                    formatter: '{b}: {c}å°'
                },
                grid: {
                    left: '10%',
                    right: '10%',
                    bottom: '15%',
                    top: '20%'
                },
                xAxis: { 
                    type: 'category', 
                    data: ['åœ¨çº¿', 'ç¦»çº¿'],
                    axisLabel: { color: '#fff' },
                    axisLine: { lineStyle: { color: '#00e4ff' } }
                },
                yAxis: { 
                    type: 'value',
                    axisLabel: { color: '#fff' },
                    axisLine: { lineStyle: { color: '#00e4ff' } },
                    splitLine: { lineStyle: { color: 'rgba(0, 228, 255, 0.2)' } }
                },
                series: [{
                    type: 'bar',
                    data: [
                        {
                            value: activeCount,
                            itemStyle: { 
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    {offset: 0, color: '#52c41a'},
                                    {offset: 1, color: '#73d13d'}
                                ])
                            }
                        },
                        {
                            value: inactiveCount,
                            itemStyle: { 
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    {offset: 0, color: '#f5222d'},
                                    {offset: 1, color: '#ff4d4f'}
                                ])
                            }
                        }
                    ],
                    label: {
                        show: true,
                        position: 'top',
                        formatter: '{c}å°',
                        color: '#fff'
                    },
                    barWidth: '50%'
                }]
            });
        }

        function updateChargingChart(data) {
            const chart = chartInstances.get('chargingChart');
            if (!chart) {
                console.error('âŒ å……ç”µå›¾è¡¨æœªåˆå§‹åŒ–');
                return;
            }
            
            const chargingCount = data.CHARGING || 0;
            const notChargingCount = data.NOT_CHARGING || 0;
            console.log('ğŸ“Š å……ç”µçŠ¶æ€å›¾è¡¨æ•°æ®:', { charging: chargingCount, notCharging: notChargingCount });
            
            chart.setOption({
                title: { 
                    text: 'å……ç”µçŠ¶æ€åˆ†å¸ƒ', 
                    textStyle: { color: '#00e4ff', fontSize: 16 },
                    left: 'center'
                },
                tooltip: { 
                    trigger: 'item',
                    formatter: '{b}: {c}å° ({d}%)'
                },
                series: [{
                    type: 'pie',
                    radius: '70%',
                    data: [
                        {
                            name: 'å……ç”µä¸­',
                            value: chargingCount,
                            itemStyle: { color: '#2196f3' }
                        },
                        {
                            name: 'æœªå……ç”µ',
                            value: notChargingCount,
                            itemStyle: { color: '#fa8c16' }
                        }
                    ],
                    label: {
                        formatter: '{b}: {c}å°\n({d}%)',
                        color: '#fff'
                    }
                }]
            });
        }

        function updateWearableChart(data) {
            const chart = chartInstances.get('wearableChart');
            if (!chart) {
                console.error('âŒ ä½©æˆ´å›¾è¡¨æœªåˆå§‹åŒ–');
                return;
            }
            
            const wornCount = data.WORN || 0;
            const notWornCount = data.NOT_WORN || 0;
            console.log('ğŸ“Š ä½©æˆ´çŠ¶æ€å›¾è¡¨æ•°æ®:', { worn: wornCount, notWorn: notWornCount });
            
            chart.setOption({
                title: { 
                    text: 'ä½©æˆ´çŠ¶æ€åˆ†å¸ƒ', 
                    textStyle: { color: '#00e4ff', fontSize: 16 },
                    left: 'center'
                },
                tooltip: { 
                    trigger: 'item',
                    formatter: '{b}: {c}å° ({d}%)'
                },
                series: [{
                    type: 'pie',
                    radius: ['40%', '70%'],
                    data: [
                        {
                            name: 'å·²ä½©æˆ´',
                            value: wornCount,
                            itemStyle: { color: '#52c41a' }
                        },
                        {
                            name: 'æœªä½©æˆ´',
                            value: notWornCount,
                            itemStyle: { color: '#f5222d' }
                        }
                    ],
                    label: {
                        formatter: '{b}: {c}å°\n({d}%)',
                        color: '#fff'
                    }
                }]
            });
        }

        function updateBatteryChart(data) {
            const chart = chartInstances.get('batteryChart');
            if (!chart) {
                console.error('âŒ ç”µæ± å›¾è¡¨æœªåˆå§‹åŒ–');
                return;
            }
            
            console.log('ğŸ“Š ç”µæ± åˆ†å¸ƒå›¾è¡¨æ•°æ®:', data);
            
            chart.setOption({
                title: { 
                    text: 'ç”µæ± ç”µé‡åˆ†å¸ƒ', 
                    textStyle: { color: '#00e4ff', fontSize: 16 },
                    left: 'center'
                },
                tooltip: { 
                    trigger: 'axis',
                    formatter: '{b}: {c}å°'
                },
                grid: {
                    left: '10%',
                    right: '10%',
                    bottom: '15%',
                    top: '20%'
                },
                xAxis: { 
                    type: 'category', 
                    data: ['0-20%', '21-70%', '71-100%'],
                    axisLabel: { color: '#fff' },
                    axisLine: { lineStyle: { color: '#00e4ff' } }
                },
                yAxis: { 
                    type: 'value',
                    axisLabel: { color: '#fff' },
                    axisLine: { lineStyle: { color: '#00e4ff' } },
                    splitLine: { lineStyle: { color: 'rgba(0, 228, 255, 0.2)' } }
                },
                series: [{
                    type: 'bar',
                    data: [
                        {
                            value: data['low'] || 0,
                            itemStyle: { color: '#f5222d' }
                        },
                        {
                            value: data['medium'] || 0,
                            itemStyle: { color: '#fa8c16' }
                        },
                        {
                            value: data['high'] || 0,
                            itemStyle: { color: '#52c41a' }
                        }
                    ],
                    label: {
                        show: true,
                        position: 'top',
                        formatter: '{c}å°',
                        color: '#fff'
                    }
                }]
            });
        }

        function updateSystemVersionChart(data) {
            const chart = chartInstances.get('systemVersionChart');
            const versions = Object.entries(data).map(([version, count]) => ({
                name: version.substring(0, 20) + (version.length > 20 ? '...' : ''),
                fullVersion: version,
                value: count
            }));

            chart.setOption({
                title: { 
                    text: 'ç³»ç»Ÿç‰ˆæœ¬åˆ†å¸ƒ', 
                    textStyle: { color: '#00e4ff', fontSize: 16 },
                    left: 'center'
                },
                tooltip: {
                    trigger: 'axis',
                    formatter: function(params) {
                        const data = params[0];
                        return `${data.data.fullVersion}<br/>æ•°é‡ï¼š${data.data.value}å°`;
                    }
                },
                grid: {
                    left: '10%',
                    right: '10%',
                    bottom: '25%',
                    top: '20%'
                },
                xAxis: {
                    type: 'category',
                    data: versions.map(v => v.name),
                    axisLabel: {
                        color: '#fff',
                        rotate: 45,
                        interval: 0
                    },
                    axisLine: { lineStyle: { color: '#00e4ff' } }
                },
                yAxis: {
                    type: 'value',
                    axisLabel: { color: '#fff' },
                    axisLine: { lineStyle: { color: '#00e4ff' } },
                    splitLine: { lineStyle: { color: 'rgba(0, 228, 255, 0.2)' } }
                },
                series: [{
                    type: 'bar',
                    data: versions.map((v, index) => ({
                        value: v.value,
                        fullVersion: v.fullVersion,
                        itemStyle: {
                            color: `hsl(${(index * 360 / versions.length)}, 70%, 60%)`
                        }
                    })),
                    label: {
                        show: true,
                        position: 'top',
                        formatter: '{c}å°',
                        color: '#fff'
                    }
                }]
            });
        }

        function updateBatteryTrendChart(batteryAnalysis) {
            const chart = chartInstances.get('batteryTrendChart');
            
            if (!batteryAnalysis || Object.keys(batteryAnalysis).length === 0) {
                chart.setOption({
                    title: { 
                        text: 'ç”µæ± è¶‹åŠ¿åˆ†æ', 
                        textStyle: { color: '#00e4ff', fontSize: 18 },
                        left: 'center'
                    },
                    graphic: {
                        type: 'text',
                        left: 'center',
                        top: 'middle',
                        style: {
                            text: 'æš‚æ— ç”µæ± åˆ†ææ•°æ®',
                            fontSize: 16,
                            fill: '#fff'
                        }
                    }
                });
                return;
            }

            const devices = Object.keys(batteryAnalysis);
            const consumptionRates = devices.map(sn => batteryAnalysis[sn].consumption_rate || 0);
            const remainingHours = devices.map(sn => batteryAnalysis[sn].hours_remaining || 0);

            chart.setOption({
                title: { 
                    text: 'ç”µæ± æ¶ˆè€—ç‡ä¸å‰©ä½™æ—¶é—´åˆ†æ', 
                    textStyle: { color: '#00e4ff', fontSize: 18 },
                    left: 'center'
                },
                tooltip: {
                    trigger: 'axis',
                    formatter: function(params) {
                        let html = `è®¾å¤‡: ${devices[params[0].dataIndex]}<br/>`;
                        params.forEach(param => {
                            html += `${param.seriesName}: ${param.value}${param.seriesName.includes('æ¶ˆè€—ç‡') ? '%/h' : 'h'}<br/>`;
                        });
                        return html;
                    }
                },
                legend: {
                    data: ['ç”µæ± æ¶ˆè€—ç‡(%/h)', 'å‰©ä½™æ—¶é—´(h)'],
                    textStyle: { color: '#fff' },
                    top: '8%'
                },
                grid: {
                    left: '8%',
                    right: '8%',
                    bottom: '15%',
                    top: '18%'
                },
                xAxis: {
                    type: 'category',
                    data: devices.map(sn => sn.substring(sn.length - 6)),
                    axisLabel: { 
                        color: '#fff',
                        rotate: 45
                    },
                    axisLine: { lineStyle: { color: '#00e4ff' } }
                },
                yAxis: [
                    {
                        type: 'value',
                        name: 'æ¶ˆè€—ç‡(%/h)',
                        position: 'left',
                        axisLabel: { color: '#fff' },
                        axisLine: { lineStyle: { color: '#00e4ff' } },
                        splitLine: { lineStyle: { color: 'rgba(0, 228, 255, 0.2)' } }
                    },
                    {
                        type: 'value',
                        name: 'æ—¶é—´(h)',
                        position: 'right',
                        axisLabel: { color: '#fff' },
                        axisLine: { lineStyle: { color: '#fa8c16' } }
                    }
                ],
                series: [
                    {
                        name: 'ç”µæ± æ¶ˆè€—ç‡(%/h)',
                        type: 'bar',
                        yAxisIndex: 0,
                        data: consumptionRates,
                        itemStyle: { color: '#00e4ff' }
                    },
                    {
                        name: 'å‰©ä½™æ—¶é—´(h)',
                    type: 'line',
                        yAxisIndex: 1,
                        data: remainingHours,
                        itemStyle: { color: '#fa8c16' }
                    }
                ]
            });
        }

        function filterDevices(devices) {
            const statusFilter = document.getElementById('filterStatus')?.value;
            const chargingFilter = document.getElementById('filterCharging')?.value;
            const wearableFilter = document.getElementById('filterWearable')?.value;
            const batteryFilter = document.getElementById('filterBattery')?.value;

            return devices.filter(device => {
                const matchStatus = !statusFilter || device.status === statusFilter;
                const matchCharging = !chargingFilter || device.charging_status === chargingFilter;
                const matchWearable = !wearableFilter || device.wearable_status === wearableFilter;
                
                let matchBattery = true;
                if (batteryFilter) {
                    const battery = parseInt(device.battery_level) || 0;
                    switch(batteryFilter) {
                        case 'low':
                            matchBattery = battery <= 20;
                            break;
                        case 'medium':
                            matchBattery = battery > 20 && battery <= 70;
                            break;
                        case 'high':
                            matchBattery = battery > 70;
                            break;
                    }
                }
                
                return matchStatus && matchCharging && matchWearable && matchBattery;
            });
        }

        function aggregateData(devices) {
            // æ ¹æ®å®é™…APIè¿”å›çš„æ•°æ®ç»“æ„è¿›è¡Œèšåˆ
            const aggregated = {
                departmentDeviceCount: {},
                deviceStatusCount: {},
                deviceChargingCount: {},
                deviceWearableCount: {},
                deviceSystemVersionCount: {},
                batteryDistribution: { low: 0, medium: 0, high: 0 }
            };

            devices.forEach(device => {
                // éƒ¨é—¨ç»Ÿè®¡
                const dept = device.department_name || 'æœªçŸ¥éƒ¨é—¨';
                aggregated.departmentDeviceCount[dept] = (aggregated.departmentDeviceCount[dept] || 0) + 1;

                // çŠ¶æ€ç»Ÿè®¡
                const status = device.status || 'UNKNOWN';
                aggregated.deviceStatusCount[status] = (aggregated.deviceStatusCount[status] || 0) + 1;
                
                const charging = device.charging_status || 'UNKNOWN';
                aggregated.deviceChargingCount[charging] = (aggregated.deviceChargingCount[charging] || 0) + 1;
                
                const wearable = device.wearable_status || 'UNKNOWN';
                aggregated.deviceWearableCount[wearable] = (aggregated.deviceWearableCount[wearable] || 0) + 1;

                // ç³»ç»Ÿç‰ˆæœ¬ç»Ÿè®¡
                const version = device.system_software_version || 'æœªçŸ¥ç‰ˆæœ¬';
                aggregated.deviceSystemVersionCount[version] = (aggregated.deviceSystemVersionCount[version] || 0) + 1;

                // ç”µæ± åˆ†å¸ƒ
                const battery = parseInt(device.battery_level) || 0;
                if (battery <= 20) aggregated.batteryDistribution.low++;
                else if (battery <= 70) aggregated.batteryDistribution.medium++;
                else aggregated.batteryDistribution.high++;
            });

            return aggregated;
        }

        function resetFilters() {
            document.getElementById('filterStatus').value = '';
            document.getElementById('filterCharging').value = '';
            document.getElementById('filterWearable').value = '';
            document.getElementById('filterBattery').value = '';
            updateDashboard();
        }

        // è·å–è®¾å¤‡å†å²è¶‹åŠ¿æ•°æ®
        async function fetchDeviceHistoryTrends(days = 7) {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const orgId = urlParams.get('orgId') || '1';
                const userId = urlParams.get('userId') || '';
                
                const response = await fetch(`/api/device/history/trends?orgId=${orgId}&userId=${userId}&days=${days}`);
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('è·å–è®¾å¤‡å†å²è¶‹åŠ¿å¤±è´¥:', error);
                return { success: false, message: error.message };
            }
        }

        // è·å–ç”µæ± é¢„æµ‹æ•°æ®
        async function fetchBatteryPrediction(days = 30) {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const orgId = urlParams.get('orgId') || '1';
                const userId = urlParams.get('userId') || '';
                
                const response = await fetch(`/api/device/battery/prediction?orgId=${orgId}&userId=${userId}&days=${days}`);
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('è·å–ç”µæ± é¢„æµ‹å¤±è´¥:', error);
                return { success: false, message: error.message };
            }
        }

        // è·å–ç»¼åˆè®¾å¤‡åˆ†ææ•°æ®
        async function fetchComprehensiveAnalysis(days = 7) {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const orgId = urlParams.get('orgId') || '1';
                const userId = urlParams.get('userId') || '';
                
                const response = await fetch(`/api/device/analysis/comprehensive?orgId=${orgId}&userId=${userId}&days=${days}`);
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('è·å–ç»¼åˆåˆ†æå¤±è´¥:', error);
                return { success: false, message: error.message };
            }
        }

        async function updateDashboard() {
            try {
                // å¦‚æœæœ‰ç¼“å­˜æ•°æ®ï¼Œä¼˜å…ˆä½¿ç”¨ç¼“å­˜æ•°æ®
                if (cachedDeviceInfo) {
                    console.log('âœ… ä½¿ç”¨ä¼ é€’çš„ç¼“å­˜æ•°æ®ï¼Œé¿å…é‡å¤æ¥å£è°ƒç”¨');
                    updateDashboardWithCachedData();
                    // è·å–å†å²è¶‹åŠ¿æ•°æ®
                    await updateHistoryTrends();
                    return Promise.resolve();
                }
                
                // æ²¡æœ‰ç¼“å­˜æ•°æ®æ—¶ï¼Œè°ƒç”¨æ¥å£è·å–
                console.log('âŒ æœªæ¥æ”¶åˆ°ç¼“å­˜æ•°æ®ï¼Œå°†è°ƒç”¨æ¥å£è·å–');
                const data = await fetchDeviceInfo();
                console.log('Fetched data:', data); // è°ƒè¯•ä¿¡æ¯
                
                if (data && data.success && data.data && data.data.devices) {
                    originalDeviceData = data;
                    const devices = data.data.devices;
                    const filtered = filterDevices(devices);
                    currentFilteredData = filtered;
                    
                    console.log('Filtered devices:', filtered.length); // è°ƒè¯•ä¿¡æ¯
                    
                    displayDeviceTable(filtered);
                    const aggregated = aggregateData(filtered);
                    
                    console.log('Aggregated data:', aggregated); // è°ƒè¯•ä¿¡æ¯
                    
                    // ä½¿ç”¨APIè¿”å›çš„ç”µæ± åˆ†ææ•°æ®
                    aggregated.batteryAnalysis = data.data.batteryAnalysis || {};
                    updateCharts(aggregated);
                    
                    // è·å–å†å²è¶‹åŠ¿æ•°æ®
                    await updateHistoryTrends();
                    return Promise.resolve();
                } else {
                    console.error('Invalid data structure:', data);
                    return Promise.reject(new Error('Invalid data structure'));
                }
            } catch (error) {
                console.error('âŒ æ›´æ–°ä»ªè¡¨æ¿å¤±è´¥:', error);
                return Promise.reject(error);
            }
        }

        // æ›´æ–°å†å²è¶‹åŠ¿å›¾è¡¨ - ä½¿ç”¨çœŸå®æ•°æ®
        async function updateHistoryTrends() {
            try {
                console.log('ğŸ”„ å¼€å§‹è·å–çœŸå®å†å²è¶‹åŠ¿æ•°æ®...');
                
                const urlParams = new URLSearchParams(window.location.search);
                const orgId = urlParams.get('orgId') || urlParams.get('customerId') || '1';
                const userId = urlParams.get('userId') || '';
                
                // è·å–çœŸå®çš„å†å²è¶‹åŠ¿æ•°æ®
                const trendsResponse = await fetch(`/api/device/history/trends?orgId=${orgId}&userId=${userId}&days=7`);
                const trendsData = await trendsResponse.json();
                
                console.log('ğŸ“Š çœŸå®è¶‹åŠ¿æ•°æ®:', trendsData);
                
                if (trendsData.success && trendsData.data && trendsData.data.chart_data) {
                    const chartData = trendsData.data.chart_data;
                    const trendsAnalysis = trendsData.data.trends_analysis;
                    
                    console.log('ğŸ“ˆ ä½¿ç”¨çœŸå®å›¾è¡¨æ•°æ®:', chartData);
                    
                    // æ›´æ–°ä½©æˆ´çŠ¶æ€è¶‹åŠ¿å›¾
                    updateWearTrendChart(chartData.wear_status_timeline);
                    
                    // æ›´æ–°å……ç”µçŠ¶æ€è¶‹åŠ¿å›¾
                    updateChargingTrendChart(chartData.charging_pattern_chart);
                    
                    // æ›´æ–°ç”µæ± ç”µé‡æ—¶åºå›¾
                    updateBatteryTrendChart(chartData.battery_trend_line);
                    
                    // æ›´æ–°è®¾å¤‡å¥åº·é›·è¾¾å›¾
                    updateDeviceHealthRadar(trendsAnalysis);
                    
                    // æ›´æ–°åœ¨çº¿ç‡è¶‹åŠ¿å›¾
                    updateUptimeTrendChart(chartData.status_uptime_chart);
                    
                    console.log('âœ… çœŸå®å†å²è¶‹åŠ¿å›¾è¡¨æ›´æ–°å®Œæˆ');
                } else {
                    console.warn('âš ï¸ æœªè·å–åˆ°æœ‰æ•ˆçš„çœŸå®è¶‹åŠ¿æ•°æ®ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®');
                    const mockData = generateMockTrendData();
                    updateWearTrendChart(mockData.wearable_status);
                    updateChargingTrendChart(mockData.charging_status);
                    updateBatteryTrendChart(mockData.battery_trend);
                    updateDeviceHealthRadar(mockData.health_radar);
                    updateUptimeTrendChart(mockData.uptime_trend);
                }
                
                // è·å–ç”µæ± é¢„æµ‹æ•°æ®
                try {
                    const predictionResponse = await fetch(`/api/device/battery/prediction?orgId=${orgId}&userId=${userId}&days=30`);
                    const predictionData = await predictionResponse.json();
                    
                    if (predictionData.success && predictionData.data && predictionData.data.chart_data) {
                        console.log('ğŸ”‹ ä½¿ç”¨çœŸå®ç”µæ± é¢„æµ‹æ•°æ®');
                        updateBatteryPredictionChart(predictionData.data.chart_data);
                    } else {
                        console.warn('âš ï¸ ç”µæ± é¢„æµ‹æ•°æ®è·å–å¤±è´¥ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®');
                        const mockData = generateMockTrendData();
                        updateBatteryPredictionChart(mockData.battery_prediction);
                    }
                } catch (error) {
                    console.error('âŒ ç”µæ± é¢„æµ‹æ•°æ®è·å–å¤±è´¥:', error);
                    const mockData = generateMockTrendData();
                    updateBatteryPredictionChart(mockData.battery_prediction);
                }
                
            } catch (error) {
                console.error('âŒ æ›´æ–°å†å²è¶‹åŠ¿å¤±è´¥:', error);
                // ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®ä½œä¸ºåå¤‡
                const mockData = generateMockTrendData();
                updateWearTrendChart(mockData.wearable_status);
                updateChargingTrendChart(mockData.charging_status);
                updateBatteryTrendChart(mockData.battery_trend);
                updateDeviceHealthRadar(mockData.health_radar);
                updateBatteryPredictionChart(mockData.battery_prediction);
                updateUptimeTrendChart(mockData.uptime_trend);
            }
        }

        // ç”Ÿæˆæ¨¡æ‹Ÿè¶‹åŠ¿æ•°æ®ç”¨äºæµ‹è¯•
        function generateMockTrendData() {
            const dates = [];
            const now = new Date();
            for (let i = 6; i >= 0; i--) {
                const date = new Date(now);
                date.setDate(date.getDate() - i);
                dates.push(date.toLocaleDateString('zh-CN', { month: '2-digit', day: '2-digit' }));
            }
            
            return {
                wearable_status: {
                    dates: dates,
                    worn_count: [3, 4, 2, 4, 3, 4, 4],
                    not_worn_count: [1, 0, 2, 0, 1, 0, 0]
                },
                charging_status: {
                    dates: dates,
                    charging_count: [1, 2, 1, 2, 1, 2, 2],
                    not_charging_count: [3, 2, 3, 2, 3, 2, 2]
                },
                battery_trend: {
                    dates: dates,
                    battery_levels: [85, 82, 78, 75, 72, 68, 65]
                },
                health_radar: {
                    battery_level: { avg_level: 75 },
                    uptime_rate: 0.85,
                    wearable_status: { wear_rate: 0.8 },
                    charging_status: { charge_rate: 0.3 },
                    system_version: { latest_rate: 0.9 }
                },
                battery_prediction: {
                    dates: ['12-20', '12-21', '12-22', '12-23', '12-24', '12-25', '12-26'],
                    historical: [85, 82, 78, 75, 72, 68, 65],
                    predicted: [62, 58, 54, 50, 46, 42, 38]
                },
                uptime_trend: {
                    dates: dates,
                    uptime_rates: [85, 90, 78, 92, 88, 95, 87]
                }
            };
        }

        function initCharts() {
            const chartIds = [
                'departmentChart', 'statusChart', 'chargingChart',
                'wearableChart', 'batteryChart', 'systemVersionChart', 'batteryTrendChart',
                'wearTrendChart', 'chargingTrendChart', 'deviceHealthRadar', 
                'batteryPredictionChart', 'uptimeTrendChart'
            ];
            
            console.log('ğŸ“ˆ å¼€å§‹åˆå§‹åŒ–å›¾è¡¨...');
            chartIds.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    const chart = echarts.init(element);
                    chartInstances.set(id, chart);
                    console.log(`âœ… å›¾è¡¨ ${id} åˆå§‹åŒ–æˆåŠŸ`);
                } else {
                    console.error(`âŒ å›¾è¡¨å®¹å™¨ ${id} ä¸å­˜åœ¨`);
                }
            });
            console.log(`ğŸ“Š å›¾è¡¨åˆå§‹åŒ–å®Œæˆï¼Œå…± ${chartInstances.size} ä¸ªå›¾è¡¨`);
        }

        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        async function initDashboard() {
            console.log('ğŸš€ å¼€å§‹åˆå§‹åŒ–ä»ªè¡¨æ¿...');
            initCharts();
            
            // ç­‰å¾…ä¸€å°æ®µæ—¶é—´ï¼Œçœ‹æ˜¯å¦æœ‰ç¼“å­˜æ•°æ®ä¼ é€’è¿‡æ¥
            setTimeout(async () => {
                if (cachedDeviceInfo) {
                    console.log('âœ… ä½¿ç”¨ä¼ é€’çš„ç¼“å­˜æ•°æ®ï¼Œé¿å…é‡å¤æ¥å£è°ƒç”¨');
                    updateDashboardWithCachedData();
                } else {
                    console.log('âŒ æœªæ¥æ”¶åˆ°ç¼“å­˜æ•°æ®ï¼Œå°†è°ƒç”¨æ¥å£è·å–');
                    await updateDashboard();
                }
                
                // å¯åŠ¨è‡ªåŠ¨åˆ·æ–°ï¼ˆ5ç§’é—´éš”ï¼‰
                if (isAutoRefreshEnabled) {
                    startAutoRefresh();
                    console.log('ğŸ”„ è‡ªåŠ¨åˆ·æ–°å·²å¯åŠ¨ï¼Œé—´éš”:', REFRESH_INTERVAL/1000, 'ç§’');
                }
            }, 1000); // ç­‰å¾…1ç§’è®©postMessageæœ‰æ—¶é—´ä¼ é€’æ•°æ®

            // çª—å£è°ƒæ•´æ—¶é‡æ–°æ¸²æŸ“å›¾è¡¨
            window.addEventListener('resize', debounce(() => {
                console.log('ğŸ”„ çª—å£å¤§å°å˜åŒ–ï¼Œé‡æ–°æ¸²æŸ“å›¾è¡¨');
                chartInstances.forEach(chart => chart.resize());
            }, 250));
            
            // é¡µé¢å¸è½½æ—¶åœæ­¢è‡ªåŠ¨åˆ·æ–°
            window.addEventListener('beforeunload', () => {
                stopAutoRefresh();
                console.log('ğŸ›‘ é¡µé¢å¸è½½ï¼Œè‡ªåŠ¨åˆ·æ–°å·²åœæ­¢');
            });
            
            // é¡µé¢éšè—æ—¶æš‚åœè‡ªåŠ¨åˆ·æ–°ï¼Œæ˜¾ç¤ºæ—¶æ¢å¤
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    stopAutoRefresh();
                    console.log('â¸ï¸ é¡µé¢éšè—ï¼Œè‡ªåŠ¨åˆ·æ–°å·²æš‚åœ');
                } else if (isAutoRefreshEnabled) {
                    startAutoRefresh();
                    console.log('â–¶ï¸ é¡µé¢æ˜¾ç¤ºï¼Œè‡ªåŠ¨åˆ·æ–°å·²æ¢å¤');
                }
            });
            
            // é»˜è®¤å±•å¼€è¿‡æ»¤å™¨é¢æ¿
            togglePanel('filterPanel');
            console.log('âœ… ä»ªè¡¨æ¿åˆå§‹åŒ–å®Œæˆ');
        }

        // æ›´æ–°ä½©æˆ´çŠ¶æ€è¶‹åŠ¿å›¾ - ä½¿ç”¨çœŸå®æ•°æ®
        function updateWearTrendChart(data) {
            const chart = chartInstances.get('wearTrendChart');
            if (!chart || !data) return;
            
            console.log('ğŸ‘• ä½©æˆ´çŠ¶æ€æ—¶åºå›¾åŸå§‹æ•°æ®:', data);
            
            // å¤„ç†æŒ‰è®¾å¤‡åˆ†ç»„çš„æ•°æ®æ ¼å¼
            const deviceSeries = [];
            const allTimestamps = new Set();
            
            // æ”¶é›†æ‰€æœ‰æ—¶é—´æˆ³
            Object.values(data).forEach(deviceData => {
                if (deviceData.timestamps) {
                    deviceData.timestamps.forEach(ts => allTimestamps.add(ts));
                }
            });
            
            // è½¬æ¢ä¸ºæ’åºçš„æ—¶é—´æ•°ç»„
            const sortedTimes = Array.from(allTimestamps).sort();
            const dates = sortedTimes.map(ts => {
                const date = new Date(ts);
                return `${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
            });
            
            // ä¸ºæ¯ä¸ªè®¾å¤‡åˆ›å»ºæ•°æ®ç³»åˆ—
            Object.entries(data).forEach(([deviceSn, deviceData], index) => {
                if (deviceData.values && deviceData.values.length > 0) {
                    const colors = ['#00e4ff', '#ff6b6b', '#ffbb00', '#a855f7'];
                    const color = colors[index % colors.length];
                    
                    deviceSeries.push({
                        name: `${deviceSn.slice(-4)}è®¾å¤‡`,
                        type: 'line',
                        data: deviceData.values,
                        smooth: false,
                        step: 'end',
                        lineStyle: { color: color, width: 2 },
                        itemStyle: { color: color }
                    });
                }
            });
            
            console.log('ğŸ‘• å¤„ç†åçš„ä½©æˆ´æ•°æ®:', { dates: dates.slice(0, 10), deviceSeries });
            
            const option = {
                title: { text: 'ä½©æˆ´çŠ¶æ€æ—¶åºå›¾', textStyle: { color: '#00e4ff', fontSize: 16 } },
                backgroundColor: 'transparent',
                grid: { left: '10%', right: '10%', top: '20%', bottom: '15%' },
                tooltip: {
                    trigger: 'axis',
                    backgroundColor: 'rgba(0,21,41,0.9)',
                    borderColor: 'rgba(0,228,255,0.5)',
                    textStyle: { color: '#fff' },
                    formatter: function(params) {
                        const time = params[0].axisValue;
                        let html = `${time}<br/>`;
                        params.forEach(param => {
                            html += `${param.seriesName}: ${param.value}å°<br/>`;
                        });
                        return html;
                    }
                },
                legend: {
                    data: deviceSeries.map(s => s.name),
                    textStyle: { color: '#7ecfff' },
                    top: '5%'
                },
                xAxis: {
                    type: 'category',
                    data: dates,
                    axisLabel: { color: '#7ecfff', fontSize: 10, rotate: 45 },
                    axisLine: { lineStyle: { color: 'rgba(0,228,255,0.3)' } }
                },
                yAxis: {
                    type: 'value',
                    min: 0, max: 1,
                    axisLabel: { 
                        color: '#7ecfff',
                        formatter: function(value) {
                            return value === 1 ? 'ä½©æˆ´' : 'æœªæˆ´';
                        }
                    },
                    axisLine: { lineStyle: { color: 'rgba(0,228,255,0.3)' } },
                    splitLine: { lineStyle: { color: 'rgba(0,228,255,0.1)' } }
                },
                series: deviceSeries
            };
            
            chart.setOption(option);
        }

        // æ›´æ–°å……ç”µçŠ¶æ€è¶‹åŠ¿å›¾ - ä½¿ç”¨çœŸå®æ•°æ®
        function updateChargingTrendChart(data) {
            const chart = chartInstances.get('chargingTrendChart');
            if (!chart || !data) return;
            
            console.log('ğŸ”Œ å……ç”µçŠ¶æ€æ—¶åºå›¾åŸå§‹æ•°æ®:', data);
            
            // å¤„ç†æŒ‰è®¾å¤‡åˆ†ç»„çš„æ•°æ®æ ¼å¼
            const deviceSeries = [];
            const allTimestamps = new Set();
            
            // æ”¶é›†æ‰€æœ‰æ—¶é—´æˆ³
            Object.values(data).forEach(deviceData => {
                if (deviceData.timestamps) {
                    deviceData.timestamps.forEach(ts => allTimestamps.add(ts));
                }
            });
            
            // è½¬æ¢ä¸ºæ’åºçš„æ—¶é—´æ•°ç»„
            const sortedTimes = Array.from(allTimestamps).sort();
            const dates = sortedTimes.map(ts => {
                const date = new Date(ts);
                return `${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
            });
            
            // ä¸ºæ¯ä¸ªè®¾å¤‡åˆ›å»ºæ•°æ®ç³»åˆ—
            Object.entries(data).forEach(([deviceSn, deviceData], index) => {
                if (deviceData.values && deviceData.values.length > 0) {
                    const colors = ['#ffbb00', '#fa8c16', '#ff6b6b', '#a855f7'];
                    const color = colors[index % colors.length];
                    
                    deviceSeries.push({
                        name: `${deviceSn.slice(-4)}è®¾å¤‡`,
                        type: 'line',
                        data: deviceData.values,
                        smooth: false,
                        step: 'end',
                        lineStyle: { color: color, width: 2 },
                        itemStyle: { color: color }
                    });
                }
            });
            
            console.log('ğŸ”Œ å¤„ç†åçš„å……ç”µæ•°æ®:', { dates: dates.slice(0, 10), deviceSeries });
            
            const option = {
                title: { text: 'å……ç”µçŠ¶æ€æ—¶åºå›¾', textStyle: { color: '#ffbb00', fontSize: 16 } },
                backgroundColor: 'transparent',
                grid: { left: '10%', right: '10%', top: '20%', bottom: '15%' },
                tooltip: {
                    trigger: 'axis',
                    backgroundColor: 'rgba(0,21,41,0.9)',
                    borderColor: 'rgba(255,187,0,0.5)',
                    textStyle: { color: '#fff' },
                    formatter: function(params) {
                        const time = params[0].axisValue;
                        let html = `${time}<br/>`;
                        params.forEach(param => {
                            html += `${param.seriesName}: ${param.value}å°<br/>`;
                        });
                        return html;
                    }
                },
                legend: {
                    data: deviceSeries.map(s => s.name),
                    textStyle: { color: '#7ecfff' },
                    top: '5%'
                },
                xAxis: {
                    type: 'category',
                    data: dates,
                    axisLabel: { color: '#7ecfff', fontSize: 10, rotate: 45 },
                    axisLine: { lineStyle: { color: 'rgba(255,187,0,0.3)' } }
                },
                yAxis: {
                    type: 'value',
                    min: 0, max: 1,
                    axisLabel: { 
                        color: '#7ecfff',
                        formatter: function(value) {
                            return value === 1 ? 'å……ç”µ' : 'å¾…æœº';
                        }
                    },
                    axisLine: { lineStyle: { color: 'rgba(255,187,0,0.3)' } },
                    splitLine: { lineStyle: { color: 'rgba(255,187,0,0.1)' } }
                },
                series: deviceSeries
            };
            
            chart.setOption(option);
        }

        // æ›´æ–°è®¾å¤‡å¥åº·é›·è¾¾å›¾ - ä½¿ç”¨çœŸå®æ•°æ®
        function updateDeviceHealthRadar(trends) {
            const chart = chartInstances.get('deviceHealthRadar');
            if (!chart || !trends) return;
            
            console.log('ğŸ¯ è®¾å¤‡å¥åº·é›·è¾¾å›¾æ•°æ®:', trends);
            
            // å¤„ç†çœŸå®è¶‹åŠ¿åˆ†ææ•°æ®
            let healthScore = { battery: 0, uptime: 0, wear: 0, charging: 0, version: 0 };
            
            if (trends.battery_trends) {
                // è®¡ç®—æ‰€æœ‰è®¾å¤‡çš„å¹³å‡ç”µæ± å¥åº·åº¦
                const batteryValues = Object.values(trends.battery_trends);
                if (batteryValues.length > 0) {
                    const avgBattery = batteryValues.reduce((sum, item) => sum + (item.avg_battery || 0), 0) / batteryValues.length;
                    healthScore.battery = Math.round(avgBattery);
                }
            }
            
            if (trends.status_stability) {
                // è®¡ç®—æ‰€æœ‰è®¾å¤‡çš„å¹³å‡åœ¨çº¿ç‡
                const uptimeValues = Object.values(trends.status_stability);
                if (uptimeValues.length > 0) {
                    const avgUptime = uptimeValues.reduce((sum, item) => sum + (item.uptime_rate || 0), 0) / uptimeValues.length;
                    healthScore.uptime = Math.round(avgUptime);
                }
            }
            
            if (trends.usage_patterns) {
                // è®¡ç®—æ‰€æœ‰è®¾å¤‡çš„å¹³å‡ä½©æˆ´ç‡
                const wearValues = Object.values(trends.usage_patterns);
                if (wearValues.length > 0) {
                    const avgWear = wearValues.reduce((sum, item) => sum + (item.wear_rate || 0), 0) / wearValues.length;
                    healthScore.wear = Math.round(avgWear);
                }
            }
            
            if (trends.charging_patterns) {
                // è®¡ç®—æ‰€æœ‰è®¾å¤‡çš„å¹³å‡å……ç”µæ•ˆç‡
                const chargingValues = Object.values(trends.charging_patterns);
                if (chargingValues.length > 0) {
                    const avgCharging = chargingValues.reduce((sum, item) => sum + (item.charging_rate || 0), 0) / chargingValues.length;
                    healthScore.charging = Math.round(avgCharging);
                }
            }
            
            if (trends.version_distribution) {
                // è®¡ç®—ç‰ˆæœ¬æ›´æ–°ç‡ï¼ˆä½¿ç”¨æœ€æ–°ç‰ˆæœ¬çš„è®¾å¤‡æ¯”ä¾‹ï¼‰
                const versionValues = Object.values(trends.version_distribution);
                if (versionValues.length > 0) {
                    const latestVersionCount = versionValues.filter(item => item.version_changes === 0).length;
                    healthScore.version = Math.round((latestVersionCount / versionValues.length) * 100);
                }
            }
            
            console.log('ğŸ“Š è®¡ç®—åçš„å¥åº·è¯„åˆ†:', healthScore);
            
            const option = {
                title: { text: 'è®¾å¤‡å¥åº·é›·è¾¾å›¾', textStyle: { color: '#fff', fontSize: 16 } },
                backgroundColor: 'transparent',
                radar: {
                    indicator: [
                        { name: 'ç”µæ± å¥åº·', max: 100 },
                        { name: 'åœ¨çº¿ç‡', max: 100 },
                        { name: 'ä½©æˆ´ç‡', max: 100 },
                        { name: 'å……ç”µæ•ˆç‡', max: 100 },
                        { name: 'ç‰ˆæœ¬æ›´æ–°ç‡', max: 100 }
                    ],
                    axisName: { color: '#7ecfff', fontSize: 12 },
                    axisLine: { lineStyle: { color: 'rgba(0,228,255,0.3)' } },
                    splitLine: { lineStyle: { color: 'rgba(0,228,255,0.2)' } },
                    splitArea: { show: false }
                },
                tooltip: {
                    trigger: 'item',
                    backgroundColor: 'rgba(0,21,41,0.9)',
                    borderColor: 'rgba(0,228,255,0.5)',
                    textStyle: { color: '#fff' }
                },
                series: [{
                    type: 'radar',
                    data: [{
                        value: [healthScore.battery, healthScore.uptime, healthScore.wear, healthScore.charging, healthScore.version],
                        name: 'è®¾å¤‡å¥åº·æŒ‡æ ‡',
                        itemStyle: { color: '#00e4ff' },
                        lineStyle: { color: '#00e4ff', width: 2 },
                        areaStyle: { 
                            color: new echarts.graphic.RadialGradient(0.5, 0.5, 0.5, [
                                { offset: 0, color: 'rgba(0,228,255,0.3)' },
                                { offset: 1, color: 'rgba(0,228,255,0.1)' }
                            ])
                        }
                    }]
                }]
            };
            chart.setOption(option);
        }

        // æ›´æ–°ç”µæ± ç”µé‡æ—¶åºå›¾ - ä½¿ç”¨çœŸå®æ•°æ®
        function updateBatteryTrendChart(data) {
            const chart = chartInstances.get('batteryTrendChart');
            if (!chart || !data) return;
            
            console.log('ğŸ”‹ ç”µæ± ç”µé‡æ—¶åºå›¾åŸå§‹æ•°æ®:', data);
            
            // å¤„ç†æŒ‰è®¾å¤‡åˆ†ç»„çš„æ•°æ®æ ¼å¼
            const deviceSeries = [];
            const allTimestamps = new Set();
            
            // æ”¶é›†æ‰€æœ‰æ—¶é—´æˆ³
            Object.values(data).forEach(deviceData => {
                if (deviceData.timestamps) {
                    deviceData.timestamps.forEach(ts => allTimestamps.add(ts));
                }
            });
            
            // è½¬æ¢ä¸ºæ’åºçš„æ—¶é—´æ•°ç»„ï¼Œå¹¶æ ¼å¼åŒ–ä¸ºå°æ—¶æ˜¾ç¤º
            const sortedTimes = Array.from(allTimestamps).sort();
            const dates = sortedTimes.map(ts => {
                const date = new Date(ts);
                return `${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
            });
            
            // ä¸ºæ¯ä¸ªè®¾å¤‡åˆ›å»ºæ•°æ®ç³»åˆ—
            Object.entries(data).forEach(([deviceSn, deviceData], index) => {
                if (deviceData.values && deviceData.values.length > 0) {
                    const colors = ['#00ff88', '#00e4ff', '#ffbb00', '#ff6b6b'];
                    const color = colors[index % colors.length];
                    
                    deviceSeries.push({
                        name: `${deviceSn.slice(-4)}è®¾å¤‡`,
                        type: 'line',
                        data: deviceData.values,
                        smooth: true,
                        lineStyle: { color: color, width: 2 },
                        itemStyle: { color: color }
                    });
                }
            });
            
            console.log('ğŸ”‹ å¤„ç†åçš„ç”µæ± æ•°æ®:', { dates: dates.slice(0, 10), deviceSeries });
            
            const option = {
                title: { text: 'ç”µæ± ç”µé‡æ—¶åºå›¾', textStyle: { color: '#00ff88', fontSize: 16 } },
                backgroundColor: 'transparent',
                grid: { left: '10%', right: '10%', top: '20%', bottom: '15%' },
                tooltip: {
                    trigger: 'axis',
                    backgroundColor: 'rgba(0,21,41,0.9)',
                    borderColor: 'rgba(0,255,136,0.5)',
                    textStyle: { color: '#fff' },
                    formatter: function(params) {
                        const time = params[0].axisValue;
                        let html = `${time}<br/>`;
                        params.forEach(param => {
                            html += `${param.seriesName}: ${param.value}%<br/>`;
                        });
                        return html;
                    }
                },
                legend: {
                    data: deviceSeries.map(s => s.name),
                    textStyle: { color: '#7ecfff' },
                    top: '5%'
                },
                xAxis: {
                    type: 'category',
                    data: dates,
                    axisLabel: { color: '#7ecfff', fontSize: 10, rotate: 45 },
                    axisLine: { lineStyle: { color: 'rgba(0,255,136,0.3)' } }
                },
                yAxis: {
                    type: 'value',
                    min: 0, max: 100,
                    axisLabel: { 
                        color: '#7ecfff',
                        formatter: '{value}%'
                    },
                    axisLine: { lineStyle: { color: 'rgba(0,255,136,0.3)' } },
                    splitLine: { lineStyle: { color: 'rgba(0,255,136,0.1)' } }
                },
                series: deviceSeries,
                markLine: {
                    data: [
                        { yAxis: 20, lineStyle: { color: '#ff6666', type: 'dashed' }, label: { formatter: 'ä½ç”µé‡è­¦æˆ’çº¿' } },
                        { yAxis: 80, lineStyle: { color: '#00ff88', type: 'dashed' }, label: { formatter: 'å……ç”µå»ºè®®çº¿' } }
                    ]
                }
            };
            
            chart.setOption(option);
        }

        // æ›´æ–°ç”µæ± é¢„æµ‹å›¾
        function updateBatteryPredictionChart(data) {
            const chart = chartInstances.get('batteryPredictionChart');
            if (!chart || !data) return;
            
            const option = {
                title: { text: 'ç”µæ± ä½¿ç”¨é¢„æµ‹', textStyle: { color: '#00ff88', fontSize: 16 } },
                backgroundColor: 'transparent',
                grid: { left: '10%', right: '10%', top: '20%', bottom: '15%' },
                tooltip: {
                    trigger: 'axis',
                    backgroundColor: 'rgba(0,21,41,0.9)',
                    borderColor: 'rgba(0,255,136,0.5)',
                    textStyle: { color: '#fff' }
                },
                legend: { 
                    data: ['å†å²æ•°æ®', 'é¢„æµ‹æ•°æ®', 'é¢„è­¦çº¿'], 
                    textStyle: { color: '#7ecfff' },
                    top: '5%'
                },
                xAxis: { 
                    type: 'category', 
                    data: data.dates, 
                    axisLabel: { color: '#7ecfff', fontSize: 10, rotate: 45 },
                    axisLine: { lineStyle: { color: 'rgba(0,255,136,0.3)' } }
                },
                yAxis: { 
                    type: 'value', 
                    name: 'ç”µé‡(%)', 
                    min: 0, max: 100, 
                    axisLabel: { color: '#7ecfff', formatter: '{value}%' },
                    axisLine: { lineStyle: { color: 'rgba(0,255,136,0.3)' } },
                    splitLine: { lineStyle: { color: 'rgba(0,255,136,0.1)' } }
                },
                series: [
                    { 
                        name: 'å†å²æ•°æ®', 
                        type: 'line', 
                        data: data.historical, 
                        itemStyle: { color: '#00ff88' },
                        lineStyle: { width: 2 }
                    },
                    { 
                        name: 'é¢„æµ‹æ•°æ®', 
                        type: 'line', 
                        data: data.predicted, 
                        itemStyle: { color: '#ffbb00' }, 
                        lineStyle: { type: 'dashed', width: 2 }
                    },
                    { 
                        name: 'é¢„è­¦çº¿', 
                        type: 'line', 
                        data: Array(data.dates.length).fill(20), 
                        itemStyle: { color: '#ff6666' }, 
                        lineStyle: { type: 'dotted', width: 2 }
                    }
                ]
            };
            chart.setOption(option);
        }

        // æ›´æ–°åœ¨çº¿ç‡è¶‹åŠ¿å›¾ - ä½¿ç”¨çœŸå®æ•°æ®
        function updateUptimeTrendChart(data) {
            const chart = chartInstances.get('uptimeTrendChart');
            if (!chart || !data) return;
            
            console.log('ğŸ“¶ åœ¨çº¿ç‡è¶‹åŠ¿å›¾åŸå§‹æ•°æ®:', data);
            
            // å¤„ç†æŒ‰è®¾å¤‡åˆ†ç»„çš„æ•°æ®æ ¼å¼
            const deviceSeries = [];
            const allTimestamps = new Set();
            
            // æ”¶é›†æ‰€æœ‰æ—¶é—´æˆ³
            Object.values(data).forEach(deviceData => {
                if (deviceData.timestamps) {
                    deviceData.timestamps.forEach(ts => allTimestamps.add(ts));
                }
            });
            
            // è½¬æ¢ä¸ºæ’åºçš„æ—¶é—´æ•°ç»„
            const sortedTimes = Array.from(allTimestamps).sort();
            const dates = sortedTimes.map(ts => {
                const date = new Date(ts);
                return `${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
            });
            
            // ä¸ºæ¯ä¸ªè®¾å¤‡åˆ›å»ºæ•°æ®ç³»åˆ—
            Object.entries(data).forEach(([deviceSn, deviceData], index) => {
                if (deviceData.values && deviceData.values.length > 0) {
                    const colors = ['#9d4edd', '#c77dff', '#e0aaff', '#ffc8dd'];
                    const color = colors[index % colors.length];
                    
                    deviceSeries.push({
                        name: `${deviceSn.slice(-4)}è®¾å¤‡`,
                        type: 'bar',
                        data: deviceData.values.map(v => v * 100), // è½¬æ¢ä¸ºç™¾åˆ†æ¯”
                        itemStyle: { 
                            color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                { offset: 0, color: color },
                                { offset: 1, color: color + '80' }
                            ])
                        }
                    });
                }
            });
            
            console.log('ğŸ“¶ å¤„ç†åçš„åœ¨çº¿ç‡æ•°æ®:', { dates: dates.slice(0, 10), deviceSeries });
            
            const option = {
                title: { text: 'è®¾å¤‡åœ¨çº¿ç‡æ—¶åºå›¾', textStyle: { color: '#9d4edd', fontSize: 16 } },
                backgroundColor: 'transparent',
                grid: { left: '10%', right: '10%', top: '20%', bottom: '15%' },
                tooltip: {
                    trigger: 'axis',
                    backgroundColor: 'rgba(0,21,41,0.9)',
                    borderColor: 'rgba(157,78,221,0.5)',
                    textStyle: { color: '#fff' },
                    formatter: function(params) {
                        const time = params[0].axisValue;
                        const rate = params[0].value;
                        return `${time}<br/>åœ¨çº¿ç‡: ${rate}%`;
                    }
                },
                legend: {
                    data: deviceSeries.map(s => s.name),
                    textStyle: { color: '#7ecfff' },
                    top: '5%'
                },
                xAxis: {
                    type: 'category',
                    data: dates,
                    axisLabel: { color: '#7ecfff', fontSize: 10, rotate: 45 },
                    axisLine: { lineStyle: { color: 'rgba(157,78,221,0.3)' } }
                },
                yAxis: {
                    type: 'value',
                    min: 0, max: 100,
                    axisLabel: { 
                        color: '#7ecfff',
                        formatter: '{value}%'
                    },
                    axisLine: { lineStyle: { color: 'rgba(157,78,221,0.3)' } },
                    splitLine: { lineStyle: { color: 'rgba(157,78,221,0.1)' } }
                },
                series: deviceSeries
            };
            
            chart.setOption(option);
        }

        document.addEventListener('DOMContentLoaded', initDashboard);
    </script>
</body>
</html>