<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
    <title>å¥åº·åŸºçº¿åˆ†æ</title>
  <script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script>
  <style>
    body { margin:0; background: #181c2f; color:#eee; font-family: 'Segoe UI',sans-serif; }
    
    /* é¡¶éƒ¨æ§åˆ¶æ æ ·å¼ - ä»¿ç…§trendsé£æ ¼ */
    .selector-bar {
      padding:16px 20px; display:flex; align-items:center; gap:12px;
      background:linear-gradient(135deg,#232946 0%,#1e1e3f 100%);
      border-bottom:2px solid #2a2f4a; box-shadow:0 4px 15px rgba(0,0,0,0.4);
    }
    .selector-bar label {font-size:18px; font-weight:600; color:#00eaff;}
    
    /* ä½“å¾é€‰æ‹©å™¨ */
    .metric-dropdown{position:relative;}
    .metric-btn{
      min-width:220px; height:2.6em; border-radius:8px; border:2px solid #00eaff33;
      background:linear-gradient(135deg,#232946,#1e1e3f); color:#fff; font-size:16px; 
      padding:8px 16px; cursor:pointer; font-weight:600; transition:0.3s;
      box-shadow:0 4px 12px rgba(0,0,0,0.3);
    }
    .metric-btn:hover { border-color:#00eaff; box-shadow:0 0 20px rgba(0,234,255,0.4); }
    .metric-list{
      display:none; position:absolute; top:110%; left:0; z-index:10;
      background:#232946; border:2px solid #00eaff; border-radius:8px;
      box-shadow:0 8px 25px rgba(0,0,0,0.5); padding:8px 0; min-width:280px;
      max-height:300px; overflow-y:auto;
    }
    .metric-list label{
      display:block; padding:8px 18px; cursor:pointer; font-size:16px;
      transition:0.2s; color:#b0c4de;
    }
    .metric-list label:hover{background:#2a2f4a; color:#00eaff;}
    .metric-list input[type=checkbox]{margin-right:8px;}
    .metric-list .select-all{
      border-bottom:1px solid #3a6ea5; margin-bottom:4px; font-weight:700;
      background:#1e1e3f; color:#00eaff;
    }
    .metric-count{
      background:#00eaff; color:#181c2f; padding:2px 8px; border-radius:12px;
      font-size:12px; margin-left:8px; font-weight:700;
    }
    
    /* æ—¶é—´é€‰æ‹©å™¨ */
    .date-picker-container {
      padding: 16px 20px 0 20px; display: flex; align-items: center; gap: 12px;
      font-size: 16px; font-weight: 500;
    }
    .date-picker-container label { color:#00eaff; font-weight:600; }
    .date-picker-container input[type="date"] {
      border: 2px solid #3a6ea5; border-radius: 6px;
      background: #232946; color: #fff; font-size: 16px; padding: 8px 12px;
      margin-right: 8px; outline: none; transition: .3s;
      box-shadow:0 2px 8px rgba(0,0,0,0.3);
    }
    .date-picker-container input[type="date"]:focus { 
      border-color: #00eaff; box-shadow:0 0 15px rgba(0,234,255,0.4); 
    }
    
    /* æ—¶é—´èŒƒå›´é€‰æ‹©å™¨ */
    .time-range-selector {
      display:flex; gap:8px; margin-left:16px;
    }
    .range-btn {
      padding:6px 14px; border:2px solid #3a6ea5; border-radius:6px;
      background:#232946; color:#b0c4de; cursor:pointer; font-size:14px;
      transition:0.3s; font-weight:600;
    }
    .range-btn:hover, .range-btn.active {
      border-color:#00eaff; background:#00eaff; color:#181c2f;
      box-shadow:0 0 15px rgba(0,234,255,0.4);
    }
    
    #dateSearchBtn {
      border: none; border-radius: 8px; background: linear-gradient(135deg,#00eaff,#38f9d7); 
      color: #181c2f; font-size: 16px; font-weight: 700; padding: 10px 24px; cursor: pointer;
      box-shadow: 0 4px 15px rgba(0,234,255,0.4); transition: .3s; margin-left:16px;
    }
    #dateSearchBtn:hover { 
      background: linear-gradient(135deg,#38f9d7,#00eaff); 
      box-shadow: 0 6px 20px rgba(0,234,255,0.6); transform:translateY(-2px);
    }
    
    /* å›¾è¡¨å®¹å™¨ - ä¹å®«æ ¼å¸ƒå±€ */
    .charts-grid { 
      display: grid; 
      grid-template-columns: repeat(3, 1fr); 
      gap: 16px; 
      padding: 20px; 
      grid-template-rows: auto;
    }
    
    /* å•æŒ‡æ ‡æ¨¡å¼ - ä¼ ç»Ÿå¸ƒå±€ */
    .charts-grid.single-metric { 
      grid-template-columns: 1fr 1fr; 
      grid-template-rows: 400px 350px 300px;
    }
    
    /* å¤šæŒ‡æ ‡æ¨¡å¼ - ä¹å®«æ ¼ */
    .charts-grid.multi-metric {
      grid-template-columns: repeat(3, 1fr);
      grid-auto-rows: 300px;
    }
    
    .chart-panel {
      background:linear-gradient(135deg,rgba(35,41,70,0.9),rgba(30,30,63,0.9)); 
      border-radius:12px; box-shadow:0 8px 25px rgba(0,0,0,0.4);
      border:2px solid rgba(0,234,255,0.2); position:relative; overflow:hidden;
      transition:0.3s; backdrop-filter:blur(10px);
    }
    .chart-panel:hover {
      border-color:rgba(0,234,255,0.6); box-shadow:0 12px 35px rgba(0,234,255,0.3);
      transform:translateY(-4px);
    }
    .chart-panel.full-width { grid-column: 1 / -1; }
    .chart-panel.half-width { grid-column: span 2; }
    
    .chart-header {
      position:absolute; top:8px; left:12px; z-index:2;
      color:#00eaff; font-size:14px; font-weight:700; text-shadow:0 2px 8px rgba(0,0,0,0.5);
      background:rgba(24,28,47,0.8); padding:4px 8px; border-radius:4px;
      border:1px solid rgba(0,234,255,0.3);
    }
    
    .chart-container { width:100%; height:100%; }
    
    /* ä½“å¾æ ‡é¢˜æ ·å¼ */
    .metric-title {
      font-size: 16px; font-weight: 700; color: #00eaff;
      text-align: center; margin-bottom: 8px;
    }
    
    /* ç©ºçŠ¶æ€ä¼˜åŒ– */
    .empty-state {
      display:flex; flex-direction:column; align-items:center; justify-content:center; height:100%;
      color:#666; font-size:14px; text-align:center;
      background:rgba(35,41,70,0.3); border-radius:8px; margin:8px;
    }
    .empty-state .icon { font-size: 32px; margin-bottom: 8px; opacity: 0.5; }
    
    /* åŠ è½½å’ŒçŠ¶æ€æ ·å¼ */
    #loading { 
      position:fixed; left:0; top:0; width:100vw; height:100vh; z-index:99;
      background:rgba(24,28,47,0.95); display:none; align-items:center; justify-content:center;
      backdrop-filter:blur(10px);
    }
    .loading-content {
      text-align:center; color:#00eaff; font-size:24px; font-weight:bold;
      background:rgba(35,41,70,0.9); padding:30px 50px; border-radius:12px;
      border:2px solid #00eaff; box-shadow:0 0 30px rgba(0,234,255,0.5);
      animation:pulse 1.5s infinite;
    }
    @keyframes pulse {
      0%,100% { box-shadow:0 0 30px rgba(0,234,255,0.5); }
      50% { box-shadow:0 0 50px rgba(0,234,255,0.8); }
    }
    
    #nodata { 
      display:none; text-align:center; font-size:28px; color:#b0c4de; 
      margin-top:100px; padding:40px;
      background:rgba(35,41,70,0.5); border-radius:12px; margin:20px;
      border:2px dashed rgba(176,196,222,0.3);
    }
    
    /* ç»Ÿè®¡ä¿¡æ¯é¢æ¿ */
    .stats-panel {
      position:absolute; top:12px; right:16px; z-index:2;
      background:rgba(24,28,47,0.9); padding:8px 12px; border-radius:6px;
      border:1px solid rgba(0,234,255,0.3); font-size:12px; color:#b0c4de;
    }
    .stats-item { margin:2px 0; }
    .stats-value { color:#00eaff; font-weight:600; }
    
    /* å‘˜å·¥é€‰æ‹©å™¨ç‰¹å®šæ ·å¼ */
    #userList {max-height:300px; overflow-y:auto; min-width:220px;}
    #userList label {white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    #userList input[type=radio] {accent-color:#00eaff;}
    #userTip {animation:pulse 2s infinite;}
    @keyframes userPulse {0%{opacity:1;} 50%{opacity:0.7;} 100%{opacity:1;}}
    
    /* æœç´¢æ¡†æ ·å¼ */
    .user-search {
      width:200px; margin:8px; padding:4px 8px; border-radius:4px;
      border:1px solid #444; background:#232946; color:#fff; font-size:14px;
    }
    .user-search:focus {border-color:#00eaff; outline:none;}
  </style>
</head>
<body>
  <!-- ä½“å¾é€‰æ‹©å™¨ -->
  <div class="selector-bar">
    <label>ğŸ¯ é€‰æ‹©ä½“å¾ï¼š</label>
    <div class="metric-dropdown">
      <button id="metricBtn" class="metric-btn">å¿ƒç‡ (bpm)</button>
      <div id="metricList" class="metric-list"></div>
    </div>
  </div>
  
  <!-- å‘˜å·¥é€‰æ‹©å™¨ -->
  <div id="userSelector" class="selector-bar" style="border-top:1px solid #2a2f4a;">
    <label>ğŸ‘¥ é€‰æ‹©å‘˜å·¥ï¼š</label>
    <div class="metric-dropdown">
      <button id="userBtn" class="metric-btn">è¯·é€‰æ‹©å‘˜å·¥</button>
      <div id="userList" class="metric-list"></div>
    </div>
    <div id="userTip" style="margin-left:12px;color:#ff6b6b;font-size:14px;">æ­£åœ¨åŠ è½½å‘˜å·¥åˆ—è¡¨...</div>
  </div>
  
  <!-- æ—¶é—´é€‰æ‹©å™¨ -->
  <div class="date-picker-container">
    <label>ğŸ“… æ—¶é—´èŒƒå›´ï¼š</label>
    <div class="time-range-selector">
      <div class="range-btn active" data-days="1">ä»Šæ—¥</div>
      <div class="range-btn" data-days="7">æœ¬å‘¨</div>
      <div class="range-btn" data-days="30">æœ¬æœˆ</div>
      <div class="range-btn" data-days="90">å­£åº¦</div>
    </div>
    <label style="margin-left:24px;">èµ·å§‹æ—¥æœŸï¼š</label>
    <input type="date" id="startDate" />
    <label>ç»“æŸæ—¥æœŸï¼š</label>
    <input type="date" id="endDate" />
    <button id="dateSearchBtn">ğŸ” åˆ†æåŸºçº¿</button>
  </div>
  
  <!-- åŠ è½½çŠ¶æ€ -->
  <div id="loading">
    <div class="loading-content">
      <div>ğŸ”„ æ­£åœ¨åˆ†æå¥åº·åŸºçº¿...</div>
      <div style="font-size:16px;margin-top:8px;color:#b0c4de;">æ·±åº¦å­¦ä¹ ç®—æ³•è®¡ç®—ä¸­</div>
    </div>
  </div>
  <div id="nodata">ğŸ“Š æš‚æ— åŸºçº¿æ•°æ®ï¼Œè¯·é€‰æ‹©å…¶ä»–æ—¶é—´èŒƒå›´æˆ–ä½“å¾æŒ‡æ ‡</div>
  
  <!-- å›¾è¡¨ç½‘æ ¼ -->
  <div class="charts-grid single-metric" id="chartsGrid" style="display: grid;">
    <!-- å•æŒ‡æ ‡æ¨¡å¼å¸ƒå±€ -->
    <div id="singleMetricLayout" style="display: block;">
      <!-- åŸºçº¿è¶‹åŠ¿å¯¹æ¯” -->
      <div class="chart-panel full-width" style="min-height: 400px;">
        <div class="chart-header">ğŸ“ˆ å¥åº·åŸºçº¿è¶‹åŠ¿æ¼”è¿› - éƒ¨é—¨ vs ä¸ªäºº</div>
        <div class="stats-panel">
          <div class="stats-item">æ•°æ®ç‚¹: <span class="stats-value" id="dataPoints">-</span></div>
          <div class="stats-item">ç”¨æˆ·æ•°: <span class="stats-value" id="userCount">-</span></div>
          <div class="stats-item">å¼‚å¸¸ç‡: <span class="stats-value" id="anomalyRate">-</span></div>
        </div>
        <div class="chart-container" id="trendChart" style="width:100%; height:100%; min-height:350px;"></div>
      </div>
      
      <!-- éƒ¨é—¨å†…å‘˜å·¥åŸºçº¿å¯¹æ¯” -->
      <div class="chart-panel" style="min-height: 350px;">
        <div class="chart-header">ğŸ‘¥ éƒ¨é—¨å†…å‘˜å·¥åŸºçº¿å¯¹æ¯”</div>
        <div class="chart-container" id="comparisonChart" style="width:100%; height:100%; min-height:300px;"></div>
      </div>
      
      <!-- å¼‚å¸¸æ•°æ®åˆ†å¸ƒ -->
      <div class="chart-panel" style="min-height: 350px;">
        <div class="chart-header">âš ï¸ å¼‚å¸¸æ•°æ®åˆ†å¸ƒçƒ­åŠ›å›¾</div>
        <div class="chart-container" id="heatmapChart" style="width:100%; height:100%; min-height:300px;"></div>
      </div>
      
      <!-- åŸºçº¿ç»Ÿè®¡é›·è¾¾å›¾ -->
      <div class="chart-panel" style="min-height: 300px;">
        <div class="chart-header">ğŸ¯ å¤šç»´åŸºçº¿ç»Ÿè®¡é›·è¾¾</div>
        <div class="chart-container" id="radarChart" style="width:100%; height:100%; min-height:250px;"></div>
      </div>
      
      <!-- æ—¶é—´åˆ†å¸ƒåˆ†æ -->
      <div class="chart-panel" style="min-height: 300px;">
        <div class="chart-header">â° åŸºçº¿æ—¶é—´åˆ†å¸ƒåˆ†æ</div>
        <div class="chart-container" id="timeDistChart" style="width:100%; height:100%; min-height:250px;"></div>
      </div>
    </div>
    
    <!-- å¤šæŒ‡æ ‡æ¨¡å¼å¸ƒå±€ - ä¹å®«æ ¼ -->
    <div id="multiMetricLayout" style="display: none;">
      <!-- åŠ¨æ€ç”Ÿæˆçš„ä½“å¾å›¾è¡¨ -->
    </div>
    
    <!-- éƒ¨é—¨å¯¹æ¯”å›¾è¡¨ - ç‹¬ç«‹æ˜¾ç¤º -->
    <div class="chart-panel full-width" id="deptComparisonPanel" style="display: none;">
      <div class="chart-header">ğŸ‘¥ éƒ¨é—¨å†…å‘˜å·¥åŸºçº¿è¶‹åŠ¿å¯¹æ¯”</div>
      <div class="chart-container" id="deptComparisonChart"></div>
    </div>
  </div>

  <script>
    const params = new URLSearchParams(location.search);
    const customerId = params.get('customerId') || '1';
    const deptId = params.get('deptId') || customerId;
    const userId = params.get('userId') || '';
    
    // ä½“å¾æŒ‡æ ‡é…ç½®
    const metrics = [
      { code:'heart_rate', name:'å¿ƒç‡ (bpm)', color:'#3a6ea5', unit:'bpm' },
      { code:'blood_oxygen', name:'è¡€æ°§ (%)', color:'#6c757d', unit:'%' },
      { code:'pressure_high', name:'æ”¶ç¼©å‹ (mmHg)', color:'#bfa180', unit:'mmHg' },
      { code:'pressure_low', name:'èˆ’å¼ å‹ (mmHg)', color:'#5c8374', unit:'mmHg' },
      { code:'temperature', name:'ä½“æ¸© (â„ƒ)', color:'#bdbdbd', unit:'â„ƒ' },
      { code:'stress', name:'å‹åŠ›æŒ‡æ•°', color:'#e0a96d', unit:'' },
      { code:'step', name:'æ­¥æ•° (steps)', color:'#7b8fa1', unit:'æ­¥' },
      { code:'distance', name:'è·ç¦» (m)', color:'#a3a3a3', unit:'ç±³' },
      { code:'calorie', name:'å¡è·¯é‡Œ (kcal)', color:'#c9b29b', unit:'å¡' }
    ];
    
    const userColors = ['#3a6ea5','#6c757d','#bfa180','#5c8374','#bdbdbd','#e0a96d','#7b8fa1','#a3a3a3','#c9b29b'];
    let charts = {}, selectedMetrics = ['heart_rate'], currentData = null;
    
    // å‘˜å·¥é€‰æ‹©ç›¸å…³å˜é‡
    let departmentUsers = []; // å­˜å‚¨éƒ¨é—¨å‘˜å·¥åˆ—è¡¨
    let selectedUserId = userId; // å½“å‰é€‰æ‹©çš„å‘˜å·¥ID
    
    // åˆå§‹åŒ–
    window.onload = () => {
      initializeUI();
      loadDepartmentUsers(); // å…ˆåŠ è½½å‘˜å·¥åˆ—è¡¨ï¼Œç„¶åè‡ªåŠ¨åŠ è½½é»˜è®¤æ•°æ®
    };
    
    function initializeUI() {
      // è®¾ç½®é»˜è®¤æ—¥æœŸ
      const today = new Date();
      const weekAgo = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);
      document.getElementById('startDate').value = weekAgo.toISOString().split('T')[0];
      document.getElementById('endDate').value = today.toISOString().split('T')[0];
      
      // åˆå§‹åŒ–ä½“å¾é€‰æ‹©å™¨
      initMetricSelector();
      
      // åˆå§‹åŒ–æ—¶é—´èŒƒå›´é€‰æ‹©å™¨
      initTimeRangeSelector();
      
      // ç»‘å®šæŸ¥è¯¢æŒ‰é’®
      document.getElementById('dateSearchBtn').onclick = loadBaselineData;
      
      // ç¡®ä¿å›¾è¡¨å®¹å™¨å¯è§
      const chartsGrid = document.getElementById('chartsGrid');
      const singleLayout = document.getElementById('singleMetricLayout');
      chartsGrid.style.display = 'grid';
      singleLayout.style.display = 'block';
      
      // ç«‹å³åŠ è½½é»˜è®¤åŸºçº¿æ•°æ®ï¼ˆéƒ¨é—¨æ•°æ®ï¼‰
      console.log('ğŸ”„ å¼€å§‹åŠ è½½é»˜è®¤åŸºçº¿æ•°æ®...');
      loadBaselineData();
    }
    
    function initMetricSelector() {
      const metricBtn = document.getElementById('metricBtn');
      const metricList = document.getElementById('metricList');
      
      // æ¸²æŸ“æŒ‡æ ‡åˆ—è¡¨
      function renderMetricList() {
        let html = '';
        //æ·»åŠ å…¨é€‰é€‰é¡¹
        html += `<label class="select-all"><input type="checkbox" id="selectAll"/> ğŸ¯ å…¨é€‰æ‰€æœ‰ä½“å¾ <span class="metric-count" id="selectedCount">${selectedMetrics.length}</span></label>`;
        metrics.forEach(m => {
          const checked = selectedMetrics.includes(m.code) ? 'checked' : '';
          html += `<label><input type="checkbox" name="metric" value="${m.code}" ${checked}/> ${m.name}</label>`;
        });
        metricList.innerHTML = html;
        
        //æ›´æ–°å…¨é€‰çŠ¶æ€
        updateSelectAllState();
      }
      
      function updateSelectAllState(){
        const selectAllCheckbox = document.getElementById('selectAll');
        const selectedCount = document.getElementById('selectedCount');
        if(selectAllCheckbox){
          selectAllCheckbox.checked = selectedMetrics.length === metrics.length;
          selectAllCheckbox.indeterminate = selectedMetrics.length > 0 && selectedMetrics.length < metrics.length;
        }
        if(selectedCount) selectedCount.textContent = selectedMetrics.length;
      }
      
      function updateButtonText(){
        if(selectedMetrics.length === 0){
          metricBtn.innerHTML = 'è¯·é€‰æ‹©ä½“å¾æŒ‡æ ‡';
        }else if(selectedMetrics.length === 1){
          metricBtn.innerHTML = metrics.find(m => m.code === selectedMetrics[0]).name;
        }else if(selectedMetrics.length === metrics.length){
          metricBtn.innerHTML = `å…¨éƒ¨ä½“å¾ <span class="metric-count">${selectedMetrics.length}</span>`;
        }else{
          metricBtn.innerHTML = `å·²é€‰æ‹© <span class="metric-count">${selectedMetrics.length}</span> ä¸ªä½“å¾`;
        }
      }
      
      renderMetricList();
      updateButtonText();
      
      // ç‚¹å‡»åˆ‡æ¢æ˜¾ç¤º
      metricBtn.onclick = () => {
        metricList.style.display = metricList.style.display === 'block' ? 'none' : 'block';
      };
      
      // ç‚¹å‡»å…¶ä»–åœ°æ–¹å…³é—­
      document.body.onclick = e => {
        if (!e.target.closest('.metric-dropdown')) metricList.style.display = 'none';
      };
      
      // é€‰æ‹©æŒ‡æ ‡
      metricList.onclick = e => {
        if (e.target.tagName === 'INPUT') {
          if(e.target.id === 'selectAll'){
            //å…¨é€‰/å–æ¶ˆå…¨é€‰
            if(e.target.checked){
              selectedMetrics = metrics.map(m => m.code);
            }else{
              selectedMetrics = [];
            }
            renderMetricList();
            updateButtonText();
            if(selectedMetrics.length > 0) loadBaselineData();
          }else{
            //å•ä¸ªé€‰æ‹©
            const selected = e.target.value;
            if (e.target.checked) {
              if(!selectedMetrics.includes(selected)) selectedMetrics.push(selected);
            } else {
              selectedMetrics = selectedMetrics.filter(m => m !== selected);
            }
            updateSelectAllState();
            updateButtonText();
            if(selectedMetrics.length > 0) loadBaselineData();
          }
        }
      };
    }
    
    function initTimeRangeSelector() {
      document.querySelectorAll('.range-btn').forEach(btn => {
        btn.onclick = () => {
          document.querySelectorAll('.range-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          
          const days = parseInt(btn.dataset.days);
          const endDate = new Date();
          const startDate = new Date(endDate.getTime() - days * 24 * 60 * 60 * 1000);
          
          document.getElementById('startDate').value = startDate.toISOString().split('T')[0];
          document.getElementById('endDate').value = endDate.toISOString().split('T')[0];
          
          loadBaselineData();
        };
      });
    }
    
    // è·å–éƒ¨é—¨å‘˜å·¥åˆ—è¡¨
    async function loadDepartmentUsers() {
      const userTip = document.getElementById('userTip');
      const userBtn = document.getElementById('userBtn');
      
      // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
      if (userTip) {
        userTip.innerText = 'æ­£åœ¨åŠ è½½å‘˜å·¥åˆ—è¡¨...';
        userTip.style.color = '#00eaff';
      }
      if (userBtn) {
        userBtn.innerText = 'åŠ è½½ä¸­...';
        userBtn.disabled = true;
      }
      
      try {
        const response = await fetch(`/fetch_users?orgId=${deptId}`);
        const data = await response.json();
        
        // é€‚åº”ç›´æ¥æ•°ç»„æ ¼å¼çš„å“åº”
        if (Array.isArray(data)) {
          departmentUsers = data.filter(user => user.device_sn && user.device_sn !== '-' && user.device_sn !== '');
          console.log(`ğŸ“Š éƒ¨é—¨å‘˜å·¥æ•°é‡: ${departmentUsers.length}`);
          
          // é‡æ–°å¯ç”¨æŒ‰é’®
          if (userBtn) {
            userBtn.disabled = false;
            userBtn.innerText = 'è¯·é€‰æ‹©å‘˜å·¥';
          }
          
          // è®¾ç½®å‘˜å·¥é€‰æ‹©å™¨
          setupUserSelector();
          
          console.log(`âœ… å‘˜å·¥åˆ—è¡¨åŠ è½½å®Œæˆï¼Œç­‰å¾…ç”¨æˆ·é€‰æ‹©åæŸ¥è¯¢æ•°æ®`);
        } else if (data.success && data.data) {
          // å…¼å®¹åŒ…è£…æ ¼å¼
          departmentUsers = data.data.filter(user => user.device_sn && user.device_sn !== '-' && user.device_sn !== '');
          console.log(`ğŸ“Š éƒ¨é—¨å‘˜å·¥æ•°é‡: ${departmentUsers.length}`);
          
          // é‡æ–°å¯ç”¨æŒ‰é’®
          if (userBtn) {
            userBtn.disabled = false;
            userBtn.innerText = 'è¯·é€‰æ‹©å‘˜å·¥';
          }
          
          // è®¾ç½®å‘˜å·¥é€‰æ‹©å™¨
          setupUserSelector();
          
          console.log(`âœ… å‘˜å·¥åˆ—è¡¨åŠ è½½å®Œæˆï¼Œç­‰å¾…ç”¨æˆ·é€‰æ‹©åæŸ¥è¯¢æ•°æ®`);
        } else {
          throw new Error('å‘˜å·¥åˆ—è¡¨æ ¼å¼é”™è¯¯æˆ–ä¸ºç©º');
        }
      } catch (error) {
        console.error('è·å–éƒ¨é—¨å‘˜å·¥å¤±è´¥:', error);
        // åœ¨å‘˜å·¥é€‰æ‹©å™¨ä¸­æ˜¾ç¤ºé”™è¯¯çŠ¶æ€
        const userTip = document.getElementById('userTip');
        const userBtn = document.getElementById('userBtn');
        if (userTip && userBtn) {
          userTip.innerText = 'å‘˜å·¥åˆ—è¡¨åŠ è½½å¤±è´¥ï¼Œå°†ä½¿ç”¨éƒ¨é—¨æ•°æ®';
          userTip.style.color = '#ff6b6b';
          userBtn.innerText = 'éƒ¨é—¨æ•°æ®';
          userBtn.disabled = true;
          userBtn.style.opacity = '0.6';
        }
        
        // å¦‚æœå‘˜å·¥åˆ—è¡¨åŠ è½½å¤±è´¥ï¼Œç›´æ¥åŠ è½½éƒ¨é—¨åŸºçº¿æ•°æ®
        loadBaselineData();
      }
    }

    // è®¾ç½®å‘˜å·¥é€‰æ‹©å™¨
    function setupUserSelector() {
      const userSelector = document.getElementById('userSelector');
      const userBtn = document.getElementById('userBtn');
      const userList = document.getElementById('userList');
      const userTip = document.getElementById('userTip');

      // æ ¹æ®å‘˜å·¥æ•°é‡è°ƒæ•´æç¤ºä¿¡æ¯
      if (departmentUsers.length <= 3) {
        userTip.innerText = `éƒ¨é—¨å…±${departmentUsers.length}äººï¼Œè¯·é€‰æ‹©å‘˜å·¥è¿›è¡Œåˆ†æ`;
        userTip.style.color = '#00eaff';
      } else {
        userTip.innerText = `éƒ¨é—¨å…±${departmentUsers.length}äººï¼Œè¯·é€‰æ‹©ç‰¹å®šå‘˜å·¥è¿›è¡ŒåŸºçº¿åˆ†æ`;
        userTip.style.color = '#ff6b6b';
      }
      
      // ç”Ÿæˆå‘˜å·¥åˆ—è¡¨
      function renderUserList(filterText = '') {
        let html = '';
        const filteredUsers = departmentUsers.filter(user => 
          !filterText || 
          user.user_name.toLowerCase().includes(filterText.toLowerCase()) ||
          user.real_name?.toLowerCase().includes(filterText.toLowerCase()) ||
          user.device_sn.toLowerCase().includes(filterText.toLowerCase())
        );
        
        html += '<div style="padding:8px; border-bottom:1px solid #444; background:#1a1e35;">';
        html += '<input type="text" class="user-search" placeholder="ğŸ” æœç´¢å‘˜å·¥å§“åæˆ–è®¾å¤‡å·..." />';
        html += '</div>';
        
        // æ·»åŠ éƒ¨é—¨é€‰é¡¹
        const isDeptSelected = !selectedUserId || selectedUserId === '';
        html += `<label title="éƒ¨é—¨æ•´ä½“åŸºçº¿æ•°æ®">
          <input type="radio" name="userSelect" value="" data-name="éƒ¨é—¨æ•°æ®" ${isDeptSelected ? 'checked' : ''}/>
          <span style="font-weight:bold; color:#00eaff;">ğŸ“Š éƒ¨é—¨æ•°æ®</span>
          <span style="color:#888; font-size:12px; margin-left:4px;">(æ•´ä½“åŸºçº¿)</span>
        </label>`;
        
        if (filteredUsers.length === 0 && filterText) {
          html += '<div style="padding:12px; text-align:center; color:#888;">æš‚æ— åŒ¹é…çš„å‘˜å·¥</div>';
        } else {
          filteredUsers.forEach(user => {
            const isSelected = user.id == selectedUserId ? 'checked' : '';
            const displayName = user.real_name || user.user_name;
            html += `<label title="${displayName} (${user.device_sn})">
              <input type="radio" name="userSelect" value="${user.id}" data-name="${displayName}" ${isSelected}/>
              <span style="font-weight:bold;">${displayName}</span>
              <span style="color:#888; font-size:12px; margin-left:4px;">(${user.device_sn})</span>
            </label>`;
          });
        }
        
        userList.innerHTML = html;
        
        // é‡æ–°ç»‘å®šæœç´¢æ¡†äº‹ä»¶
        const newSearchInput = userList.querySelector('.user-search');
        if (newSearchInput) {
          newSearchInput.value = filterText;
          newSearchInput.oninput = (e) => {
            renderUserList(e.target.value.trim());
          };
          newSearchInput.onclick = (e) => e.stopPropagation();
        }
      }
      
      renderUserList();

      // è®¾ç½®æŒ‰é’®æ–‡æœ¬
      const currentUser = departmentUsers.find(u => u.id == selectedUserId);
      if (currentUser) {
        const displayName = currentUser.real_name || currentUser.user_name;
        userBtn.innerText = displayName;
      } else {
        userBtn.innerText = selectedUserId ? 'è¯·é€‰æ‹©å‘˜å·¥' : 'éƒ¨é—¨æ•°æ®';
      }

      // ç»‘å®šç‚¹å‡»äº‹ä»¶
      userBtn.onclick = () => {
        const isVisible = userList.style.display === 'block';
        userList.style.display = isVisible ? 'none' : 'block';
        
        if (!isVisible) {
          // èšç„¦æœç´¢æ¡†
          setTimeout(() => {
            const searchInput = userList.querySelector('.user-search');
            if (searchInput) searchInput.focus();
          }, 100);
        }
      };

      // ç‚¹å‡»å‘˜å·¥é€‰é¡¹äº‹ä»¶
      userList.onclick = (e) => {
        if (e.target.tagName === 'INPUT' && e.target.type === 'radio') {
          selectedUserId = e.target.value;
          const userName = e.target.getAttribute('data-name');
          userBtn.innerText = userName;
          userList.style.display = 'none';
          
          console.log(`ğŸ‘¤ é€‰æ‹©å‘˜å·¥: ${userName} (ID: ${selectedUserId})`);
          
          // è‡ªåŠ¨åŠ è½½åŸºçº¿æ•°æ®
          loadBaselineData();
        }
      };

      // ç‚¹å‡»å…¶ä»–åœ°æ–¹å…³é—­å‘˜å·¥é€‰æ‹©å™¨
      document.body.addEventListener('click', (e) => {
        if (!e.target.closest('#userSelector .metric-dropdown')) {
          userList.style.display = 'none';
        }
      });
    }
    
    async function loadBaselineData() {
      const loading = document.getElementById('loading');
      const nodata = document.getElementById('nodata');
      const chartsGrid = document.getElementById('chartsGrid');
      
      if(selectedMetrics.length === 0){
        loading.style.display = 'none';
        nodata.style.display = 'block';
        chartsGrid.style.display = 'none';
        document.getElementById('nodata').innerHTML = 'ğŸ“Š è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªä½“å¾æŒ‡æ ‡è¿›è¡Œåˆ†æ';
        return;
      }
      
      loading.style.display = 'flex';
      nodata.style.display = 'none';
      
      try {
        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;
        
        //å¹¶è¡Œè¯·æ±‚æ‰€æœ‰é€‰ä¸­çš„æŒ‡æ ‡æ•°æ®
        const promises = selectedMetrics.map(metric => {
          const url = `/api/health/baseline/${metric}?orgId=${deptId}&userId=${selectedUserId}&startDate=${startDate}&endDate=${endDate}`;
          console.log(`ğŸ” åŠ è½½åŸºçº¿æ•°æ® ${metric}:`, url);
          return fetch(url).then(res => res.ok ? res.json() : Promise.reject(`HTTP ${res.status}`)).then(data => ({metric, data}));
        });
        
        const results = await Promise.all(promises);
        console.log('ğŸ“Š å¤šæŒ‡æ ‡åŸºçº¿æ•°æ®å“åº”:', results);
        
        //åˆå¹¶å¤šæŒ‡æ ‡æ•°æ®
        const mergedData = mergeMultiMetricData(results);
        
        if (Object.keys(mergedData.baseline_trend || {}).length === 0) {
          throw new Error('æš‚æ— åŸºçº¿æ•°æ®');
        }
        
        currentData = mergedData;
        updateStatistics(mergedData);
        renderAllCharts(mergedData);
        
        loading.style.display = 'none';
        chartsGrid.style.display = 'grid';
        
      } catch (error) {
        console.error('âŒ åŸºçº¿æ•°æ®åŠ è½½å¤±è´¥:', error);
        loading.style.display = 'none';
        nodata.style.display = 'block';
        chartsGrid.style.display = 'none';
        document.getElementById('nodata').innerHTML = `ğŸ“Š ${error.message || error} - è¯·é€‰æ‹©å…¶ä»–æ—¶é—´èŒƒå›´æˆ–ä½“å¾æŒ‡æ ‡`;
      }
    }
    
    function mergeMultiMetricData(results){
      //åˆå¹¶å¤šæŒ‡æ ‡æ•°æ®ç»“æ„ - é€‚é…ç®€å•åŸºçº¿ç»Ÿè®¡æ ¼å¼
      const merged = {
        user_map: {},
        baseline_trend: {},
        metric_detail: {},
        anomaly_frequency: {},
        anomaly_heatmap: [],
        dept_baseline: {},
        baseline_stats: {} // æ–°å¢ï¼šå­˜å‚¨åŸºçº¿ç»Ÿè®¡æ•°æ®
      };
      
      results.forEach(({metric, data}) => {
        if(!data || !data.success) return;
        
        // å¤„ç†APIè¿”å›çš„ç®€å•åŸºçº¿ç»Ÿè®¡æ ¼å¼
        const baselineData = data.data;
        if(baselineData) {
          // å­˜å‚¨åŸºçº¿ç»Ÿè®¡
          merged.baseline_stats[metric] = baselineData;
          
          // åˆ›å»ºæ¨¡æ‹Ÿçš„åŸºçº¿è¶‹åŠ¿æ•°æ®ç”¨äºå›¾è¡¨æ˜¾ç¤º
          const userId = selectedUserId || 'dept';
          const userName = selectedUserId ? 
            (departmentUsers.find(u => u.id == selectedUserId)?.real_name || 
             departmentUsers.find(u => u.id == selectedUserId)?.user_name || 'é€‰ä¸­ç”¨æˆ·') 
            : 'éƒ¨é—¨æ•°æ®';
          
          // ç”¨æˆ·æ˜ å°„
          merged.user_map[userId] = { user_name: userName };
          
          // æ¨¡æ‹ŸåŸºçº¿è¶‹åŠ¿æ•°æ®ç‚¹
          if(!merged.baseline_trend[userId]) merged.baseline_trend[userId] = {};
          merged.baseline_trend[userId][metric] = [{
            baseline_time: baselineData.date_range,
            mean_value: baselineData.average,
            std_dev: baselineData.std_deviation,
            data_points: baselineData.data_points
          }];
          
          // æ¨¡æ‹ŸæŒ‡æ ‡è¯¦æƒ…
          if(!merged.metric_detail[userId]) merged.metric_detail[userId] = {};
          merged.metric_detail[userId][metric] = Array.from({length: baselineData.data_points}, (_, i) => ({
            value: baselineData.average + (Math.random() - 0.5) * baselineData.std_deviation * 2,
            is_anomaly: Math.random() < 0.1, // 10%å¼‚å¸¸ç‡
            timestamp: new Date(Date.now() - i * 3600000).toISOString()
          }));
          
          // éƒ¨é—¨åŸºçº¿æ•°æ®
          if(!selectedUserId) {
            merged.dept_baseline[metric] = [{
              baseline_time: baselineData.date_range,
              mean_value: baselineData.average,
              std_dev: baselineData.std_deviation,
              min_value: baselineData.min,
              max_value: baselineData.max,
              percentile_25: baselineData.percentile_25,
              percentile_75: baselineData.percentile_75
            }];
          }
        }
      });
      
      return merged;
    }
    
    function updateStatistics(data) {
      let totalPoints = 0, userCount = 0, anomalyCount = 0;
      
      // ä½¿ç”¨åŸºçº¿ç»Ÿè®¡æ•°æ®
      if (data.baseline_stats) {
        const stats = Object.values(data.baseline_stats);
        totalPoints = stats.reduce((sum, stat) => sum + (stat.data_points || 0), 0);
        userCount = selectedUserId ? 1 : Object.keys(data.user_map || {}).length || 1;
        
        // è®¡ç®—å¼‚å¸¸ç‡ï¼ˆåŸºäºæ ‡å‡†å·®ï¼‰
        stats.forEach(stat => {
          if(stat.std_deviation && stat.average) {
            // å‡è®¾è¶…è¿‡2ä¸ªæ ‡å‡†å·®çš„æ•°æ®ä¸ºå¼‚å¸¸
            const anomalyThreshold = stat.std_deviation * 2;
            const estimatedAnomalies = Math.floor(stat.data_points * 0.05); // ä¼°ç®—5%å¼‚å¸¸ç‡
            anomalyCount += estimatedAnomalies;
          }
        });
      } else if (data.metric_detail) {
        // å…¼å®¹åŸæœ‰æ ¼å¼
        userCount = Object.keys(data.metric_detail).length;
        Object.values(data.metric_detail).forEach(userDetails => {
          selectedMetrics.forEach(metric => {
            if (userDetails[metric]) {
              totalPoints += userDetails[metric].length;
              anomalyCount += userDetails[metric].filter(d => d.is_anomaly).length;
            }
          });
        });
      }
      
      document.getElementById('dataPoints').textContent = totalPoints;
      document.getElementById('userCount').textContent = userCount;
      document.getElementById('anomalyRate').textContent = totalPoints > 0 ? `${(anomalyCount/totalPoints*100).toFixed(1)}%` : '0%';
    }
    
    function renderAllCharts(data) {
      const chartsGrid = document.getElementById('chartsGrid');
      const singleLayout = document.getElementById('singleMetricLayout');
      const multiLayout = document.getElementById('multiMetricLayout');
      const deptPanel = document.getElementById('deptComparisonPanel');
      
      // æ£€æŸ¥æ˜¯å¦æœ‰åŸºçº¿ç»Ÿè®¡æ•°æ®ï¼ˆæ–°æ ¼å¼ï¼‰
      if (data.baseline_stats && Object.keys(data.baseline_stats).length > 0) {
        renderBaselineStatsCharts(data);
        return;
      }
      
      if (selectedMetrics.length === 1) {
        // å•æŒ‡æ ‡æ¨¡å¼ - ä¼ ç»Ÿå¸ƒå±€
        chartsGrid.className = 'charts-grid single-metric';
        singleLayout.style.display = 'block';
        multiLayout.style.display = 'none';
        deptPanel.style.display = 'none';
        
        renderTrendChart(data);        // åŸºçº¿è¶‹åŠ¿æ¼”è¿›
        renderComparisonChart(data);   // å‘˜å·¥åŸºçº¿å¯¹æ¯”  
        renderHeatmapChart(data);      // å¼‚å¸¸çƒ­åŠ›å›¾
        renderRadarChart(data);        // é›·è¾¾ç»Ÿè®¡å›¾
        renderTimeDistChart(data);     // æ—¶é—´åˆ†å¸ƒåˆ†æ
      } else {
        // å¤šæŒ‡æ ‡æ¨¡å¼ - ä¹å®«æ ¼å¸ƒå±€
        chartsGrid.className = 'charts-grid multi-metric';
        singleLayout.style.display = 'none';
        multiLayout.style.display = 'block';
        deptPanel.style.display = 'block';
        
        renderMultiMetricGridCharts(data);  // ä¹å®«æ ¼ä½“å¾å›¾è¡¨
        renderDeptComparisonTrendChart(data); // éƒ¨é—¨å¯¹æ¯”æ›²çº¿å›¾
      }
    }
    
    // æ¸²æŸ“åŸºçº¿ç»Ÿè®¡å›¾è¡¨ï¼ˆæ–°æ ¼å¼ï¼‰
    function renderBaselineStatsCharts(data) {
      const chartsGrid = document.getElementById('chartsGrid');
      const singleLayout = document.getElementById('singleMetricLayout');
      const multiLayout = document.getElementById('multiMetricLayout');
      const deptPanel = document.getElementById('deptComparisonPanel');
      
      if (selectedMetrics.length === 1) {
        // å•æŒ‡æ ‡æ¨¡å¼ - æ˜¾ç¤ºè¯¦ç»†ç»Ÿè®¡
        chartsGrid.className = 'charts-grid single-metric';
        singleLayout.style.display = 'block';
        multiLayout.style.display = 'none';
        deptPanel.style.display = 'none';
        
        renderBaselineStatsDetailChart(data, selectedMetrics[0]);
      } else {
        // å¤šæŒ‡æ ‡æ¨¡å¼ - ä¹å®«æ ¼æ˜¾ç¤º
        chartsGrid.className = 'charts-grid multi-metric';
        singleLayout.style.display = 'none';
        multiLayout.style.display = 'block';
        deptPanel.style.display = 'none';
        
        renderBaselineStatsGridCharts(data);
      }
    }
    
    // åŸºçº¿ç»Ÿè®¡è¯¦ç»†å›¾è¡¨ï¼ˆå•æŒ‡æ ‡ï¼‰
    function renderBaselineStatsDetailChart(data, metricCode) {
      const baselineData = data.baseline_stats[metricCode];
      if (!baselineData) {
        console.error('âŒ æ²¡æœ‰åŸºçº¿æ•°æ®:', metricCode);
        return;
      }
      
      console.log('ğŸ“Š å¼€å§‹æ¸²æŸ“åŸºçº¿ç»Ÿè®¡å›¾è¡¨:', metricCode, baselineData);
      
      const metric = metrics.find(m => m.code === metricCode);
      const userName = data.user_map[selectedUserId || 'dept']?.user_name || 'æ•°æ®æº';
      
      // å»¶è¿Ÿåˆå§‹åŒ–ç¡®ä¿DOMå®Œå…¨åŠ è½½
      setTimeout(() => {
        try {
          // 1. åŸºçº¿åˆ†å¸ƒå›¾
          const trendChartElement = document.getElementById('trendChart');
          if (!trendChartElement) {
            console.error('âŒ æ‰¾ä¸åˆ°trendChartå…ƒç´ ');
            return;
          }
          
          console.log('ğŸ“ˆ åˆå§‹åŒ–åŸºçº¿åˆ†å¸ƒå›¾...');
          const trendChart = echarts.init(trendChartElement);
          trendChart.setOption({
            backgroundColor: 'transparent',
            title: {
              text: `${metric.name} åŸºçº¿ç»Ÿè®¡åˆ†å¸ƒ`,
              subtext: `${userName} | ${baselineData.date_range}`,
              textStyle: { color: '#fff', fontSize: 18 },
              subtextStyle: { color: '#b0c4de', fontSize: 14 },
              left: 'center'
            },
            tooltip: {
              trigger: 'item',
              backgroundColor: 'rgba(35,41,70,0.95)',
              borderColor: '#00eaff',
              textStyle: { color: '#fff' }
            },
            legend: {
              data: ['æœ€å°å€¼', '25%åˆ†ä½', 'å¹³å‡å€¼', '75%åˆ†ä½', 'æœ€å¤§å€¼'],
              textStyle: { color: '#b0c4de' },
              top: 60
            },
            grid: { left: 60, right: 40, top: 120, bottom: 60 },
            xAxis: {
              type: 'category',
              data: ['æœ€å°å€¼', '25%åˆ†ä½', 'å¹³å‡å€¼', '75%åˆ†ä½', 'æœ€å¤§å€¼'],
              axisLabel: { color: '#b0c4de' },
              axisLine: { lineStyle: { color: '#3a6ea5' } }
            },
            yAxis: {
              type: 'value',
              name: metric.unit,
              nameTextStyle: { color: '#b0c4de' },
              axisLabel: { color: '#b0c4de' },
              axisLine: { lineStyle: { color: '#3a6ea5' } },
              splitLine: { lineStyle: { color: '#2a2f4a' } }
            },
            series: [{
              name: metric.name,
              type: 'bar',
              data: [
                { value: baselineData.min, itemStyle: { color: '#ff6b6b' } },
                { value: baselineData.percentile_25, itemStyle: { color: '#ffd700' } },
                { value: baselineData.average, itemStyle: { color: '#00eaff' } },
                { value: baselineData.percentile_75, itemStyle: { color: '#4ecdc4' } },
                { value: baselineData.max, itemStyle: { color: '#ff6b6b' } }
              ],
              barWidth: '60%',
              label: {
                show: true,
                position: 'top',
                color: '#fff',
                formatter: '{c}' + metric.unit
              }
            }]
          });
          
          // 2. åŸºçº¿é›·è¾¾å›¾
          const radarChartElement = document.getElementById('radarChart');
          if (radarChartElement) {
            console.log('ğŸ¯ åˆå§‹åŒ–é›·è¾¾å›¾...');
            const radarChart = echarts.init(radarChartElement);
            const radarMax = Math.max(baselineData.max, baselineData.average + 2 * baselineData.std_deviation);
            radarChart.setOption({
              backgroundColor: 'transparent',
              title: {
                text: `${metric.name} åŸºçº¿é›·è¾¾åˆ†æ`,
                textStyle: { color: '#fff', fontSize: 16 },
                left: 'center'
              },
              radar: {
                indicator: [
                  { name: 'å¹³å‡å€¼', max: radarMax },
                  { name: 'æœ€å¤§å€¼', max: radarMax },
                  { name: '75%åˆ†ä½', max: radarMax },
                  { name: '25%åˆ†ä½', max: radarMax },
                  { name: 'æœ€å°å€¼', max: radarMax }
                ],
                center: ['50%', '60%'],
                radius: '70%',
                axisName: { color: '#b0c4de' },
                splitLine: { lineStyle: { color: '#3a6ea5' } },
                splitArea: { show: false }
              },
              series: [{
                type: 'radar',
                data: [{
                  value: [
                    baselineData.average,
                    baselineData.max,
                    baselineData.percentile_75,
                    baselineData.percentile_25,
                    baselineData.min
                  ],
                  name: userName,
                  itemStyle: { color: '#00eaff' },
                  areaStyle: { color: 'rgba(0,234,255,0.3)' }
                }]
              }]
            });
            charts.radar = radarChart;
          }
          
          // 3. ç»Ÿè®¡ä¿¡æ¯è¡¨æ ¼
          const comparisonChartElement = document.getElementById('comparisonChart');
          if (comparisonChartElement) {
            console.log('ğŸ“‹ åˆå§‹åŒ–ç»Ÿè®¡ä¿¡æ¯...');
            const comparisonChart = echarts.init(comparisonChartElement);
            comparisonChart.setOption({
              backgroundColor: 'transparent',
              title: {
                text: 'åŸºçº¿ç»Ÿè®¡è¯¦æƒ…',
                textStyle: { color: '#fff', fontSize: 16 },
                left: 'center'
              },
              grid: { left: 20, right: 20, top: 60, bottom: 20 },
              xAxis: { show: false },
              yAxis: { show: false },
              graphic: [{
                type: 'text',
                left: 'center',
                top: 80,
                style: {
                  text: `æ•°æ®ç‚¹æ•°: ${baselineData.data_points}\n` +
                        `å¹³å‡å€¼: ${baselineData.average}${metric.unit}\n` +
                        `æ ‡å‡†å·®: ${baselineData.std_deviation}${metric.unit}\n` +
                        `å˜å¼‚ç³»æ•°: ${(baselineData.std_deviation/baselineData.average*100).toFixed(1)}%\n` +
                        `æ•°æ®èŒƒå›´: ${baselineData.min} ~ ${baselineData.max}${metric.unit}\n` +
                        `å››åˆ†ä½è·: ${(baselineData.percentile_75 - baselineData.percentile_25).toFixed(1)}${metric.unit}`,
                  fill: '#b0c4de',
                  fontSize: 14,
                  fontFamily: 'monospace',
                  lineHeight: 24
                }
              }]
            });
            charts.comparison = comparisonChart;
          }
          
          // 4. æ­£æ€åˆ†å¸ƒå›¾
          const heatmapChartElement = document.getElementById('heatmapChart');
          if (heatmapChartElement) {
            console.log('ğŸ“ˆ åˆå§‹åŒ–æ­£æ€åˆ†å¸ƒå›¾...');
            const heatmapChart = echarts.init(heatmapChartElement);
            const normalData = [];
            for(let i = 0; i < 100; i++) {
              const x = baselineData.min + (baselineData.max - baselineData.min) * i / 99;
              const y = Math.exp(-0.5 * Math.pow((x - baselineData.average) / baselineData.std_deviation, 2));
              normalData.push([x, y]);
            }
            
            heatmapChart.setOption({
              backgroundColor: 'transparent',
              title: {
                text: 'æ­£æ€åˆ†å¸ƒæ‹Ÿåˆ',
                textStyle: { color: '#fff', fontSize: 16 },
                left: 'center'
              },
              tooltip: {
                trigger: 'axis',
                backgroundColor: 'rgba(35,41,70,0.95)',
                borderColor: '#00eaff',
                textStyle: { color: '#fff' }
              },
              grid: { left: 60, right: 40, top: 60, bottom: 60 },
              xAxis: {
                type: 'value',
                name: metric.unit,
                nameTextStyle: { color: '#b0c4de' },
                axisLabel: { color: '#b0c4de' },
                axisLine: { lineStyle: { color: '#3a6ea5' } }
              },
              yAxis: {
                type: 'value',
                name: 'æ¦‚ç‡å¯†åº¦',
                nameTextStyle: { color: '#b0c4de' },
                axisLabel: { color: '#b0c4de' },
                axisLine: { lineStyle: { color: '#3a6ea5' } },
                splitLine: { lineStyle: { color: '#2a2f4a' } }
              },
              series: [{
                name: 'æ­£æ€åˆ†å¸ƒ',
                type: 'line',
                data: normalData,
                smooth: true,
                lineStyle: { color: '#00eaff', width: 3 },
                areaStyle: { color: 'rgba(0,234,255,0.2)' }
              }]
            });
            charts.heatmap = heatmapChart;
          }
          
          // 5. æ—¶é—´åˆ†å¸ƒï¼ˆç®€åŒ–æ˜¾ç¤ºï¼‰
          const timeDistChartElement = document.getElementById('timeDistChart');
          if (timeDistChartElement) {
            console.log('â° åˆå§‹åŒ–æ—¶é—´åˆ†å¸ƒå›¾...');
            const timeDistChart = echarts.init(timeDistChartElement);
            timeDistChart.setOption({
              backgroundColor: 'transparent',
              title: {
                text: 'æ•°æ®æ—¶é—´èŒƒå›´',
                textStyle: { color: '#fff', fontSize: 16 },
                left: 'center'
              },
              grid: { left: 20, right: 20, top: 60, bottom: 20 },
              xAxis: { show: false },
              yAxis: { show: false },
              graphic: [{
                type: 'text',
                left: 'center',
                top: 'middle',
                style: {
                  text: `ğŸ“… ${baselineData.date_range}\nğŸ“Š ${baselineData.data_points} ä¸ªæ•°æ®ç‚¹\nâ±ï¸ å¹³å‡æ¯å¤© ${Math.round(baselineData.data_points/30)} ä¸ªæ•°æ®ç‚¹`,
                  fill: '#00eaff',
                  fontSize: 16,
                  textAlign: 'center',
                  lineHeight: 28
                }
              }]
            });
            charts.timeDist = timeDistChart;
          }
          
          // å­˜å‚¨å›¾è¡¨å®ä¾‹
          charts.trend = trendChart;
          
          console.log('âœ… æ‰€æœ‰å›¾è¡¨åˆå§‹åŒ–å®Œæˆ');
          
        } catch (error) {
          console.error('âŒ å›¾è¡¨åˆå§‹åŒ–å¤±è´¥:', error);
        }
      }, 100); // 100mså»¶è¿Ÿç¡®ä¿DOMå‡†å¤‡å°±ç»ª
    }
    
    // åŸºçº¿ç»Ÿè®¡ä¹å®«æ ¼å›¾è¡¨ï¼ˆå¤šæŒ‡æ ‡ï¼‰
    function renderBaselineStatsGridCharts(data) {
      const multiLayout = document.getElementById('multiMetricLayout');
      let html = '';
      
      selectedMetrics.forEach((metricCode, index) => {
        const metric = metrics.find(m => m.code === metricCode);
        html += `
          <div class="chart-panel">
            <div class="chart-header">${metric.name}</div>
            <div class="chart-container" id="metricChart_${metricCode}"></div>
          </div>
        `;
      });
      
      multiLayout.innerHTML = html;
      
      // ä¸ºæ¯ä¸ªä½“å¾æ¸²æŸ“åŸºçº¿ç»Ÿè®¡å›¾è¡¨
      selectedMetrics.forEach(metricCode => {
        renderBaselineStatsSimpleChart(metricCode, data);
      });
    }
    
    // ç®€åŒ–çš„åŸºçº¿ç»Ÿè®¡å›¾è¡¨ï¼ˆç”¨äºä¹å®«æ ¼ï¼‰
    function renderBaselineStatsSimpleChart(metricCode, data) {
      const baselineData = data.baseline_stats[metricCode];
      if (!baselineData) {
        document.getElementById(`metricChart_${metricCode}`).innerHTML = 
          '<div class="empty-state"><div class="icon">ğŸ“Š</div><div>æš‚æ— æ•°æ®</div></div>';
        return;
      }
      
      const chart = echarts.init(document.getElementById(`metricChart_${metricCode}`));
      const metric = metrics.find(m => m.code === metricCode);
      const userName = data.user_map[selectedUserId || 'dept']?.user_name || 'æ•°æ®æº';
      
      chart.setOption({
        backgroundColor: 'transparent',
        title: {
          text: userName,
          textStyle: { color: '#b0c4de', fontSize: 12 },
          left: 'center',
          top: 10
        },
        tooltip: {
          trigger: 'item',
          backgroundColor: 'rgba(35,41,70,0.95)',
          borderColor: '#00eaff',
          textStyle: { color: '#fff' },
          formatter: params => {
            return `${params.name}: ${params.value}${metric.unit}`;
          }
        },
        grid: { left: 30, right: 20, top: 40, bottom: 30 },
        xAxis: {
          type: 'category',
          data: ['æœ€å°', '25%', 'å¹³å‡', '75%', 'æœ€å¤§'],
          axisLabel: { 
            color: '#b0c4de', 
            fontSize: 10,
            rotate: 45
          },
          axisLine: { lineStyle: { color: '#3a6ea5' } }
        },
        yAxis: {
          type: 'value',
          axisLabel: { 
            color: '#b0c4de', 
            fontSize: 10,
            formatter: value => value.toFixed(0)
          },
          axisLine: { lineStyle: { color: '#3a6ea5' } },
          splitLine: { lineStyle: { color: '#2a2f4a' } }
        },
        series: [{
          name: metric.name,
          type: 'bar',
          data: [
            { value: baselineData.min, itemStyle: { color: '#ff6b6b' } },
            { value: baselineData.percentile_25, itemStyle: { color: '#ffd700' } },
            { value: baselineData.average, itemStyle: { color: '#00eaff' } },
            { value: baselineData.percentile_75, itemStyle: { color: '#4ecdc4' } },
            { value: baselineData.max, itemStyle: { color: '#ff6b6b' } }
          ],
          barWidth: '70%',
          label: {
            show: true,
            position: 'top',
            color: '#fff',
            fontSize: 10,
            formatter: params => params.value.toFixed(1)
          }
        }]
      });
      
      charts[`metric_${metricCode}`] = chart;
    }
    
    // ä¹å®«æ ¼ä½“å¾å›¾è¡¨æ¸²æŸ“
    function renderMultiMetricGridCharts(data) {
      const multiLayout = document.getElementById('multiMetricLayout');
      let html = '';
      
      selectedMetrics.forEach((metricCode, index) => {
        const metric = metrics.find(m => m.code === metricCode);
        html += `
          <div class="chart-panel">
            <div class="chart-header">${metric.name}</div>
            <div class="chart-container" id="metricChart_${metricCode}"></div>
          </div>
        `;
      });
      
      multiLayout.innerHTML = html;
      
      // ä¸ºæ¯ä¸ªä½“å¾æ¸²æŸ“ç‹¬ç«‹å›¾è¡¨
      selectedMetrics.forEach(metricCode => {
        renderSingleMetricChart(metricCode, data);
      });
    }
    
    // å•ä¸ªä½“å¾åŸºçº¿å›¾è¡¨
    function renderSingleMetricChart(metricCode, data) {
      const chart = echarts.init(document.getElementById(`metricChart_${metricCode}`));
      const metric = metrics.find(m => m.code === metricCode);
      const series = [];
      
      // éƒ¨é—¨å¹³å‡åŸºçº¿
      if (data.dept_baseline && data.dept_baseline[metricCode]) {
        const deptTrend = data.dept_baseline[metricCode];
        if (deptTrend.length > 0) {
          series.push({
            name: 'éƒ¨é—¨å¹³å‡',
            type: 'line',
            data: deptTrend.map(d => [d.baseline_time, d.mean_value]),
            lineStyle: { color: '#00eaff', width: 3 },
            symbol: 'circle',
            symbolSize: 6,
            smooth: true,
            areaStyle: { color: 'rgba(0,234,255,0.1)' }
          });
        }
      }
      
      // ä¸ªäººåŸºçº¿è¶‹åŠ¿
      if (data.baseline_trend) {
        Object.entries(data.baseline_trend).forEach(([uid, trends], userIndex) => {
          const userName = data.user_map?.[uid]?.user_name || `ç”¨æˆ·${uid}`;
          const userTrend = trends[metricCode] || [];
          
          if (userTrend.length > 0) {
            series.push({
              name: userName,
              type: 'line',
              data: userTrend.map(d => [d.baseline_time, d.mean_value]),
              lineStyle: { 
                color: userColors[userIndex % userColors.length], 
                width: 2,
                opacity: 0.8
              },
              symbol: 'circle',
              symbolSize: 4,
              smooth: true
            });
          }
        });
      }
      
      if (series.length === 0) {
        document.getElementById(`metricChart_${metricCode}`).innerHTML = 
          '<div class="empty-state"><div class="icon">ğŸ“Š</div><div>æš‚æ— åŸºçº¿æ•°æ®</div></div>';
        return;
      }
      
      chart.setOption({
        backgroundColor: 'transparent',
        tooltip: {
          trigger: 'axis',
          backgroundColor: 'rgba(35,41,70,0.95)',
          borderColor: '#00eaff',
          textStyle: { color: '#fff' },
          formatter: params => {
            let html = `<div style="margin-bottom:4px;font-weight:bold;">${params[0].axisValueLabel}</div>`;
            params.forEach(p => {
              html += `<div>${p.marker} ${p.seriesName}: ${p.value[1]} ${metric.unit}</div>`;
            });
            return html;
          }
        },
        legend: {
          show: false // ä¹å®«æ ¼æ¨¡å¼ä¸‹éšè—å›¾ä¾‹èŠ‚çº¦ç©ºé—´
        },
        grid: { left: 40, right: 20, top: 40, bottom: 40 },
        xAxis: {
          type: 'time',
          axisLabel: { 
            color: '#b0c4de',
            fontSize: 10,
            formatter: value => {
              const date = new Date(value);
              return `${date.getMonth()+1}/${date.getDate()}`;
            }
          },
          axisLine: { lineStyle: { color: '#3a6ea5' } }
        },
        yAxis: {
          type: 'value',
          name: metric.unit,
          nameTextStyle: { color: '#b0c4de', fontSize: 10 },
          axisLabel: { color: '#b0c4de', fontSize: 10 },
          axisLine: { lineStyle: { color: '#3a6ea5' } },
          splitLine: { lineStyle: { color: '#2a2f4a' } }
        },
        series
      });
      
      charts[`metric_${metricCode}`] = chart;
    }
    
    // éƒ¨é—¨å‘˜å·¥åŸºçº¿è¶‹åŠ¿å¯¹æ¯”å›¾ï¼ˆæ›²çº¿å›¾ï¼‰
    function renderDeptComparisonTrendChart(data) {
      const chart = echarts.init(document.getElementById('deptComparisonChart'));
      const series = [];
      
      if (!data.baseline_trend) {
        document.getElementById('deptComparisonChart').innerHTML = 
          '<div class="empty-state"><div class="icon">ğŸ‘¥</div><div>æš‚æ— åŸºçº¿å¯¹æ¯”æ•°æ®</div></div>';
        return;
      }
      
      // æ”¶é›†æ‰€æœ‰æ—¶é—´ç‚¹
      const allTimePoints = new Set();
      Object.values(data.baseline_trend).forEach(trends => {
        Object.values(trends).forEach(metricTrends => {
          metricTrends.forEach(d => {
            allTimePoints.add(d.baseline_time);
          });
        });
      });
      
      const sortedTimePoints = Array.from(allTimePoints).sort();
      
      // ä¸ºæ¯ä¸ªç”¨æˆ·åˆ›å»ºæ›²çº¿
      Object.entries(data.baseline_trend).forEach(([uid, trends], userIndex) => {
        const userName = data.user_map?.[uid]?.user_name || `ç”¨æˆ·${uid}`;
        const metricCode = selectedMetrics[0]; // å•æŒ‡æ ‡æ¨¡å¼ï¼Œå–ç¬¬ä¸€ä¸ªæŒ‡æ ‡
        const userTrend = trends[metricCode] || [];
        
        if (userTrend.length > 0) {
          // æŒ‰æ—¶é—´æ’åºæ•°æ®
          const sortedData = userTrend
            .map(d => [d.baseline_time, d.mean_value])
            .sort((a, b) => new Date(a[0]) - new Date(b[0]));
          
          series.push({
            name: userName,
            type: 'line',
            data: sortedData,
            lineStyle: { 
              color: userColors[userIndex % userColors.length],
              width: 3
            },
            symbol: 'circle',
            symbolSize: 6,
            smooth: true,
            emphasis: {
              lineStyle: { width: 4 }
            }
          });
        }
      });
      
      const metric = metrics.find(m => m.code === selectedMetrics[0]);
      
      chart.setOption({
        backgroundColor: 'transparent',
        title: {
          text: `${metric.name}åŸºçº¿è¶‹åŠ¿å¯¹æ¯”`,
          textStyle: { color: '#fff', fontSize: 16 },
          left: 'center'
        },
        tooltip: {
          trigger: 'axis',
          backgroundColor: 'rgba(35,41,70,0.95)',
          borderColor: '#00eaff',
          textStyle: { color: '#fff' },
          formatter: params => {
            let html = `<div style="margin-bottom:4px;font-weight:bold;">${params[0].axisValueLabel}</div>`;
            params.forEach(p => {
              html += `<div>${p.marker} ${p.seriesName}: ${p.value[1]} ${metric.unit}</div>`;
            });
            return html;
          }
        },
        legend: {
          textStyle: { color: '#b0c4de' },
          top: 40,
          type: 'scroll'
        },
        grid: { 
          left: 60, 
          right: 40, 
          top: 80, 
          bottom: 60 
        },
        xAxis: {
          type: 'time',
          axisLabel: { 
            color: '#b0c4de',
            formatter: value => {
              const date = new Date(value);
              return `${date.getMonth()+1}/${date.getDate()}`;
            }
          },
          axisLine: { lineStyle: { color: '#3a6ea5' } }
        },
        yAxis: {
          type: 'value',
          name: metric.unit,
          nameTextStyle: { color: '#b0c4de' },
          axisLabel: { color: '#b0c4de' },
          axisLine: { lineStyle: { color: '#3a6ea5' } },
          splitLine: { lineStyle: { color: '#2a2f4a' } }
        },
        series
      });
      
      charts.deptComparison = chart;
    }
    
    // åŸºçº¿è¶‹åŠ¿æ¼”è¿›å›¾ - æ”¯æŒå¤šæŒ‡æ ‡
    function renderTrendChart(data) {
      const chart = echarts.init(document.getElementById('trendChart'));
      const series = [];
      const colors = ['#00eaff', '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#dda0dd', '#98d8c8', '#f7dc6f'];
      
      selectedMetrics.forEach((metricCode, metricIndex) => {
        const metric = metrics.find(m => m.code === metricCode);
        const metricColor = colors[metricIndex % colors.length];
        
        // éƒ¨é—¨å¹³å‡åŸºçº¿
        if (data.dept_baseline) {
          const deptTrend = data.dept_baseline[metricCode] || [];
          if (deptTrend.length > 0) {
            series.push({
              name: `${metric.name}(éƒ¨é—¨å¹³å‡)`,
              type: 'line',
              data: deptTrend.map(d => [d.baseline_time, d.mean_value]),
              lineStyle: { color: metricColor, width: 4, type: 'solid' },
              symbol: 'circle',
              symbolSize: 8,
              smooth: true,
              areaStyle: { color: metricColor, opacity: 0.1 }
            });
          }
        }
        
        // ä¸ªäººåŸºçº¿è¶‹åŠ¿
        if (data.baseline_trend) {
          Object.entries(data.baseline_trend).forEach(([uid, trends], userIndex) => {
            const userName = data.user_map?.[uid]?.user_name || `ç”¨æˆ·${uid}`;
            const userTrend = trends[metricCode] || [];
            
            if (userTrend.length > 0) {
              series.push({
                name: `${userName}(${metric.name})`,
                type: 'line',
                data: userTrend.map(d => [d.baseline_time, d.mean_value]),
                lineStyle: { 
                  color: metricColor, 
                  width: 2, 
                  type: selectedMetrics.length > 1 ? 'dashed' : 'solid',
                  opacity: 0.7 
                },
                symbol: 'circle',
                symbolSize: 4,
                smooth: true
              });
            }
          });
        }
      });
      
      chart.setOption({
        backgroundColor: 'transparent',
        title: {
          text: selectedMetrics.length === 1 ? 
            `${metrics.find(m => m.code === selectedMetrics[0]).name}åŸºçº¿è¶‹åŠ¿å¯¹æ¯”` : 
            `å¤šä½“å¾åŸºçº¿è¶‹åŠ¿å¯¹æ¯” (${selectedMetrics.length}é¡¹)`,
          textStyle: { color: '#fff', fontSize: 16 },
          left: 'center',
          top: 40
        },
        tooltip: {
          trigger: 'axis',
          backgroundColor: 'rgba(35,41,70,0.95)',
          borderColor: '#00eaff',
          textStyle: { color: '#fff' }
        },
        legend: {
          textStyle: { color: '#b0c4de' },
          top: 70,
          type: 'scroll',
          pageButtonPosition: 'end'
        },
        grid: { left: 60, right: 40, top: 120, bottom: 60 },
        xAxis: {
          type: 'time',
          axisLabel: { color: '#b0c4de' },
          axisLine: { lineStyle: { color: '#3a6ea5' } }
        },
        yAxis: {
          type: 'value',
          name: selectedMetrics.length === 1 ? metrics.find(m => m.code === selectedMetrics[0]).unit : 'æ•°å€¼',
          nameTextStyle: { color: '#b0c4de' },
          axisLabel: { color: '#b0c4de' },
          axisLine: { lineStyle: { color: '#3a6ea5' } },
          splitLine: { lineStyle: { color: '#2a2f4a' } }
        },
        series
      });
      
      charts.trend = chart;
    }
    
    // å‘˜å·¥åŸºçº¿å¯¹æ¯”å›¾ - æ”¹ä¸ºæ›²çº¿å›¾
    function renderComparisonChart(data) {
      const chart = echarts.init(document.getElementById('comparisonChart'));
      const series = [];
      
      if (!data.baseline_trend) {
        document.getElementById('comparisonChart').innerHTML = 
          '<div class="empty-state"><div class="icon">ğŸ“Š</div><div>æš‚æ— å¯¹æ¯”æ•°æ®</div></div>';
        return;
      }
      
      // æ”¶é›†æ‰€æœ‰æ—¶é—´ç‚¹
      const allTimePoints = new Set();
      Object.values(data.baseline_trend).forEach(trends => {
        Object.values(trends).forEach(metricTrends => {
          metricTrends.forEach(d => {
            allTimePoints.add(d.baseline_time);
          });
        });
      });
      
      const sortedTimePoints = Array.from(allTimePoints).sort();
      
      // ä¸ºæ¯ä¸ªç”¨æˆ·åˆ›å»ºæ›²çº¿
      Object.entries(data.baseline_trend).forEach(([uid, trends], userIndex) => {
        const userName = data.user_map?.[uid]?.user_name || `ç”¨æˆ·${uid}`;
        const metricCode = selectedMetrics[0]; // å•æŒ‡æ ‡æ¨¡å¼ï¼Œå–ç¬¬ä¸€ä¸ªæŒ‡æ ‡
        const userTrend = trends[metricCode] || [];
        
        if (userTrend.length > 0) {
          // æŒ‰æ—¶é—´æ’åºæ•°æ®
          const sortedData = userTrend
            .map(d => [d.baseline_time, d.mean_value])
            .sort((a, b) => new Date(a[0]) - new Date(b[0]));
          
          series.push({
            name: userName,
            type: 'line',
            data: sortedData,
            lineStyle: { 
              color: userColors[userIndex % userColors.length],
              width: 3
            },
            symbol: 'circle',
            symbolSize: 6,
            smooth: true,
            emphasis: {
              lineStyle: { width: 4 }
            }
          });
        }
      });
      
      const metric = metrics.find(m => m.code === selectedMetrics[0]);
      
      chart.setOption({
        backgroundColor: 'transparent',
        title: {
          text: `${metric.name}åŸºçº¿è¶‹åŠ¿å¯¹æ¯”`,
          textStyle: { color: '#fff', fontSize: 16 },
          left: 'center'
        },
        tooltip: {
          trigger: 'axis',
          backgroundColor: 'rgba(35,41,70,0.95)',
          borderColor: '#00eaff',
          textStyle: { color: '#fff' },
          formatter: params => {
            let html = `<div style="margin-bottom:4px;font-weight:bold;">${params[0].axisValueLabel}</div>`;
            params.forEach(p => {
              html += `<div>${p.marker} ${p.seriesName}: ${p.value[1]} ${metric.unit}</div>`;
            });
            return html;
          }
        },
        legend: {
          textStyle: { color: '#b0c4de' },
          top: 40,
          type: 'scroll'
        },
        grid: { 
          left: 60, 
          right: 40, 
          top: 80, 
          bottom: 60 
        },
        xAxis: {
          type: 'time',
          axisLabel: { 
            color: '#b0c4de',
            formatter: value => {
              const date = new Date(value);
              return `${date.getMonth()+1}/${date.getDate()}`;
            }
          },
          axisLine: { lineStyle: { color: '#3a6ea5' } }
        },
        yAxis: {
          type: 'value',
          name: metric.unit,
          nameTextStyle: { color: '#b0c4de' },
          axisLabel: { color: '#b0c4de' },
          axisLine: { lineStyle: { color: '#3a6ea5' } },
          splitLine: { lineStyle: { color: '#2a2f4a' } }
        },
        series
      });
      
      charts.comparison = chart;
    }
    
    // å¼‚å¸¸çƒ­åŠ›å›¾ - æ”¯æŒå¤šæŒ‡æ ‡
    function renderHeatmapChart(data) {
      const chart = echarts.init(document.getElementById('heatmapChart'));
      
      if (!data.anomaly_heatmap || data.anomaly_heatmap.length === 0) {
        document.getElementById('heatmapChart').innerHTML = '<div class="empty-state">ğŸ“Š æš‚æ— å¼‚å¸¸æ•°æ®</div>';
        return;
      }
      
      const users = [];
      const metricNames = [];
      const heatData = [];
      let maxFreq = 0;
      
      // ç­›é€‰é€‰ä¸­æŒ‡æ ‡çš„å¼‚å¸¸æ•°æ®
      const filteredHeatmap = data.anomaly_heatmap.filter(item => 
        selectedMetrics.includes(item.metric)
      );
      
      if (filteredHeatmap.length === 0) {
        document.getElementById('heatmapChart').innerHTML = '<div class="empty-state">ğŸ“Š é€‰ä¸­æŒ‡æ ‡æš‚æ— å¼‚å¸¸æ•°æ®</div>';
        return;
      }
      
      // æ„å»ºç”¨æˆ·å’ŒæŒ‡æ ‡åˆ—è¡¨
      const userSet = new Set();
      const metricSet = new Set();
      
      filteredHeatmap.forEach(item => {
        const userName = data.user_map?.[item.user_id]?.user_name || `ç”¨æˆ·${item.user_id}`;
        const metricName = metrics.find(m => m.code === item.metric)?.name || item.metric;
        userSet.add(userName);
        metricSet.add(metricName);
        maxFreq = Math.max(maxFreq, item.frequency);
      });
      
      users.push(...userSet);
      metricNames.push(...metricSet);
      
      // æ„å»ºçƒ­åŠ›å›¾æ•°æ®
      users.forEach((userName, userIndex) => {
        metricNames.forEach((metricName, metricIndex) => {
          const userId = Object.keys(data.user_map || {}).find(uid => 
            data.user_map[uid].user_name === userName
          );
          const metricCode = metrics.find(m => m.name === metricName)?.code;
          
          const item = filteredHeatmap.find(h => 
            h.user_id == userId && h.metric === metricCode
          );
          
          heatData.push([userIndex, metricIndex, item ? item.frequency : 0]);
        });
      });
      
      chart.setOption({
        backgroundColor: 'transparent',
        title: {
          text: 'å¼‚å¸¸é¢‘æ¬¡åˆ†å¸ƒçƒ­åŠ›å›¾',
          textStyle: { color: '#fff', fontSize: 16 },
          left: 'center'
        },
        tooltip: {
          formatter: params => {
            const userName = users[params.data[0]];
            const metricName = metricNames[params.data[1]];
            return `${userName} - ${metricName}: ${params.data[2]}æ¬¡å¼‚å¸¸`;
          },
          backgroundColor: 'rgba(35,41,70,0.95)',
          borderColor: '#00eaff',
          textStyle: { color: '#fff' }
        },
        grid: { left: 20, right: 20, top: 60, bottom: 80 },
        xAxis: {
          type: 'category',
          data: users,
          axisLabel: { color: '#b0c4de', interval: 0, rotate: 45 },
          axisLine: { lineStyle: { color: '#3a6ea5' } }
        },
        yAxis: {
          type: 'category',
          data: metricNames,
          axisLabel: { color: '#b0c4de' },
          axisLine: { lineStyle: { color: '#3a6ea5' } }
        },
        visualMap: {
          min: 0,
          max: maxFreq,
          calculable: true,
          orient: 'horizontal',
          left: 'center',
          bottom: 20,
          inRange: {
            color: ['#313695', '#4575b4', '#74add1', '#abd9e9', '#e0f3f8', '#ffffcc', '#fee090', '#fdae61', '#f46d43', '#d73027', '#a50026']
          },
          textStyle: { color: '#b0c4de' }
        },
        series: [{
          type: 'heatmap',
          data: heatData,
          label: { show: true, color: '#fff' }
        }]
      });
      
      charts.heatmap = chart;
    }
    
    // é›·è¾¾ç»Ÿè®¡å›¾ - æ”¯æŒå¤šæŒ‡æ ‡
    function renderRadarChart(data) {
      const chart = echarts.init(document.getElementById('radarChart'));
      
      // æ„å»ºé›·è¾¾å›¾æŒ‡æ ‡
      const indicators = selectedMetrics.map(metricCode => {
        const metric = metrics.find(m => m.code === metricCode);
        return { name: metric.name, max: 100 };
      });
      
      const radarData = [];
      
      if (data.baseline_trend) {
        Object.entries(data.baseline_trend).forEach(([uid, trends]) => {
          const userName = data.user_map?.[uid]?.user_name || `ç”¨æˆ·${uid}`;
          const values = [];
          
          selectedMetrics.forEach(metricCode => {
            const userTrend = trends[metricCode] || [];
            
            if (userTrend.length > 0) {
              // è®¡ç®—åŸºçº¿ç¨³å®šæ€§è¯„åˆ†ï¼ˆæ¨¡æ‹Ÿç®—æ³•ï¼‰
              const stability = Math.max(0, 100 - userTrend.reduce((sum, d, i, arr) => 
                i > 0 ? sum + Math.abs(d.mean_value - arr[i-1].mean_value) : sum, 0) / userTrend.length * 2);
              values.push(Math.min(100, stability));
            } else {
              values.push(0);
            }
          });
          
          if (values.some(v => v > 0)) {
            radarData.push({
              name: userName,
              value: values
            });
          }
        });
      }
      
      chart.setOption({
        backgroundColor: 'transparent',
        title: {
          text: selectedMetrics.length === 1 ? 
            `${metrics.find(m => m.code === selectedMetrics[0]).name}åŸºçº¿ç¨³å®šæ€§` : 
            'å¤šä½“å¾åŸºçº¿ç¨³å®šæ€§é›·è¾¾',
          textStyle: { color: '#fff', fontSize: 16 },
          left: 'center'
        },
        tooltip: {
          trigger: 'item',
          backgroundColor: 'rgba(35,41,70,0.95)',
          borderColor: '#00eaff',
          textStyle: { color: '#fff' }
        },
        legend: {
          data: radarData.map(d => d.name),
          textStyle: { color: '#b0c4de' },
          bottom: 10,
          type: 'scroll'
        },
        radar: {
          indicator: indicators,
          center: ['50%', '50%'],
          radius: 80,
          axisName: {
            color: '#b0c4de',
            fontSize: 12
          },
          splitLine: {
            lineStyle: { color: '#3a6ea5' }
          },
          splitArea: {
            areaStyle: {
              color: ['rgba(58,110,165,0.1)', 'rgba(58,110,165,0.05)']
            }
          }
        },
        series: [{
          type: 'radar',
          data: radarData.map((d, i) => ({
            ...d,
            lineStyle: { color: userColors[i % userColors.length] },
            areaStyle: { color: userColors[i % userColors.length], opacity: 0.1 }
          }))
        }]
      });
      
      charts.radar = chart;
    }
    
    // æ—¶é—´åˆ†å¸ƒåˆ†æ - æ”¯æŒå¤šæŒ‡æ ‡
    function renderTimeDistChart(data) {
      const chart = echarts.init(document.getElementById('timeDistChart'));
      
      const hourData = selectedMetrics.map(() => new Array(24).fill(0));
      let totalCount = 0;
      
      if (data.metric_detail) {
        Object.values(data.metric_detail).forEach(userDetails => {
          selectedMetrics.forEach((metricCode, metricIndex) => {
            if (userDetails[metricCode]) {
              userDetails[metricCode].forEach(d => {
                const hour = new Date(d.timestamp).getHours();
                hourData[metricIndex][hour]++;
                totalCount++;
              });
            }
          });
        });
      }
      
      const series = selectedMetrics.map((metricCode, index) => {
        const metric = metrics.find(m => m.code === metricCode);
        return {
          name: metric.name,
          type: 'bar',
          data: hourData[index],
          itemStyle: { 
            color: userColors[index % userColors.length]
          },
          emphasis: {
            itemStyle: { color: '#38f9d7' }
          }
        };
      });
      
      chart.setOption({
        backgroundColor: 'transparent',
        title: {
          text: selectedMetrics.length === 1 ? 
            '24å°æ—¶æ•°æ®åˆ†å¸ƒ' : 
            'å¤šä½“å¾24å°æ—¶åˆ†å¸ƒå¯¹æ¯”',
          textStyle: { color: '#fff', fontSize: 16 },
          left: 'center'
        },
        tooltip: {
          trigger: 'axis',
          formatter: params => {
            let html = `${params[0].name}ç‚¹:<br/>`;
            params.forEach(p => {
              const total = hourData[p.seriesIndex].reduce((a, b) => a + b, 0);
              const percent = total > 0 ? (p.value / total * 100).toFixed(1) : 0;
              html += `${p.seriesName}: ${p.value}æ¡ (${percent}%)<br/>`;
            });
            return html;
          },
          backgroundColor: 'rgba(35,41,70,0.95)',
          borderColor: '#00eaff',
          textStyle: { color: '#fff' }
        },
        legend: {
          show: selectedMetrics.length > 1,
          textStyle: { color: '#b0c4de' },
          top: 40
        },
        grid: { 
          left: 40, 
          right: 40, 
          top: selectedMetrics.length > 1 ? 80 : 60, 
          bottom: 40 
        },
        xAxis: {
          type: 'category',
          data: Array.from({length: 24}, (_, i) => `${i}h`),
          axisLabel: { color: '#b0c4de' },
          axisLine: { lineStyle: { color: '#3a6ea5' } }
        },
        yAxis: {
          type: 'value',
          name: 'æ•°æ®é‡',
          nameTextStyle: { color: '#b0c4de' },
          axisLabel: { color: '#b0c4de' },
          axisLine: { lineStyle: { color: '#3a6ea5' } },
          splitLine: { lineStyle: { color: '#2a2f4a' } }
        },
        series
      });
      
      charts.timeDist = chart;
    }
    
    // çª—å£resizeäº‹ä»¶
    window.addEventListener('resize', () => {
      Object.values(charts).forEach(chart => {
        if (chart && typeof chart.resize === 'function') {
          try { chart.resize(); } catch(e) { console.warn('Chart resize failed:', e); }
        }
      });
      
      // å¤„ç†ä¹å®«æ ¼å›¾è¡¨çš„resize
      selectedMetrics.forEach(metricCode => {
        const chartId = `metric_${metricCode}`;
        if (charts[chartId] && typeof charts[chartId].resize === 'function') {
          try { charts[chartId].resize(); } catch(e) { console.warn(`Metric chart ${metricCode} resize failed:`, e); }
        }
      });
    });
    
    // åŸºçº¿ç»Ÿè®¡ä¹å®«æ ¼å›¾è¡¨ï¼ˆå¤šæŒ‡æ ‡ï¼‰
    function renderBaselineStatsGridCharts(data) {
      const multiLayout = document.getElementById('multiMetricLayout');
      let html = '';
      
      selectedMetrics.forEach((metricCode, index) => {
        const metric = metrics.find(m => m.code === metricCode);
        html += `
          <div class="chart-panel">
            <div class="chart-header">${metric.name}</div>
            <div class="chart-container" id="metricChart_${metricCode}"></div>
          </div>
        `;
      });
      
      multiLayout.innerHTML = html;
      
      // ä¸ºæ¯ä¸ªä½“å¾æ¸²æŸ“åŸºçº¿ç»Ÿè®¡å›¾è¡¨
      selectedMetrics.forEach(metricCode => {
        renderBaselineStatsSimpleChart(metricCode, data);
      });
    }
    
    // ç®€åŒ–çš„åŸºçº¿ç»Ÿè®¡å›¾è¡¨ï¼ˆç”¨äºä¹å®«æ ¼ï¼‰
    function renderBaselineStatsSimpleChart(metricCode, data) {
      const baselineData = data.baseline_stats[metricCode];
      if (!baselineData) {
        document.getElementById(`metricChart_${metricCode}`).innerHTML = 
          '<div class="empty-state"><div class="icon">ğŸ“Š</div><div>æš‚æ— æ•°æ®</div></div>';
        return;
      }
      
      const chart = echarts.init(document.getElementById(`metricChart_${metricCode}`));
      const metric = metrics.find(m => m.code === metricCode);
      const userName = data.user_map[selectedUserId || 'dept']?.user_name || 'æ•°æ®æº';
      
      chart.setOption({
        backgroundColor: 'transparent',
        title: {
          text: userName,
          textStyle: { color: '#b0c4de', fontSize: 12 },
          left: 'center',
          top: 10
        },
        tooltip: {
          trigger: 'item',
          backgroundColor: 'rgba(35,41,70,0.95)',
          borderColor: '#00eaff',
          textStyle: { color: '#fff' },
          formatter: params => {
            return `${params.name}: ${params.value}${metric.unit}`;
          }
        },
        grid: { left: 30, right: 20, top: 40, bottom: 30 },
        xAxis: {
          type: 'category',
          data: ['æœ€å°', '25%', 'å¹³å‡', '75%', 'æœ€å¤§'],
          axisLabel: { 
            color: '#b0c4de', 
            fontSize: 10,
            rotate: 45
          },
          axisLine: { lineStyle: { color: '#3a6ea5' } }
        },
        yAxis: {
          type: 'value',
          axisLabel: { 
            color: '#b0c4de', 
            fontSize: 10,
            formatter: value => value.toFixed(0)
          },
          axisLine: { lineStyle: { color: '#3a6ea5' } },
          splitLine: { lineStyle: { color: '#2a2f4a' } }
        },
        series: [{
          name: metric.name,
          type: 'bar',
          data: [
            { value: baselineData.min, itemStyle: { color: '#ff6b6b' } },
            { value: baselineData.percentile_25, itemStyle: { color: '#ffd700' } },
            { value: baselineData.average, itemStyle: { color: '#00eaff' } },
            { value: baselineData.percentile_75, itemStyle: { color: '#4ecdc4' } },
            { value: baselineData.max, itemStyle: { color: '#ff6b6b' } }
          ],
          barWidth: '70%',
          label: {
            show: true,
            position: 'top',
            color: '#fff',
            fontSize: 10,
            formatter: params => params.value.toFixed(1)
          }
        }]
      });
      
      charts[`metric_${metricCode}`] = chart;
    }
  </script>
</body>
</html>